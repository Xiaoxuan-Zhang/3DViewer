(()=>{var n={7228:n=>{n.exports=function(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}},2858:n=>{n.exports=function(n){if(Array.isArray(n))return n}},3646:(n,e,t)=>{var o=t(7228);n.exports=function(n){if(Array.isArray(n))return o(n)}},1506:n=>{n.exports=function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}},4575:n=>{n.exports=function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}},3913:n=>{function e(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}n.exports=function(n,t,o){return t&&e(n.prototype,t),o&&e(n,o),n}},9713:n=>{n.exports=function(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}},9754:n=>{function e(t){return n.exports=e=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)},e(t)}n.exports=e},2205:(n,e,t)=>{var o=t(9489);n.exports=function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&o(n,e)}},6860:n=>{n.exports=function(n){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(n))return Array.from(n)}},3884:n=>{n.exports=function(n,e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(n)){var t=[],o=!0,r=!1,i=void 0;try{for(var a,c=n[Symbol.iterator]();!(o=(a=c.next()).done)&&(t.push(a.value),!e||t.length!==e);o=!0);}catch(n){r=!0,i=n}finally{try{o||null==c.return||c.return()}finally{if(r)throw i}}return t}}},521:n=>{n.exports=function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}},8206:n=>{n.exports=function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}},8585:(n,e,t)=>{var o=t(8),r=t(1506);n.exports=function(n,e){return!e||"object"!==o(e)&&"function"!=typeof e?r(n):e}},9489:n=>{function e(t,o){return n.exports=e=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n},e(t,o)}n.exports=e},3038:(n,e,t)=>{var o=t(2858),r=t(3884),i=t(379),a=t(521);n.exports=function(n,e){return o(n)||r(n,e)||i(n,e)||a()}},319:(n,e,t)=>{var o=t(3646),r=t(6860),i=t(379),a=t(8206);n.exports=function(n){return o(n)||r(n)||i(n)||a()}},8:n=>{function e(t){return"function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?n.exports=e=function(n){return typeof n}:n.exports=e=function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},e(t)}n.exports=e},379:(n,e,t)=>{var o=t(7228);n.exports=function(n,e){if(n){if("string"==typeof n)return o(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?o(n,e):void 0}}},4578:(n,e,t)=>{"use strict";t.d(e,{Z:()=>c});var o=t(4015),r=t.n(o),i=t(3645),a=t.n(i)()(r());a.push([n.id,'.tabs{border-radius:0px;overflow:hidden;box-shadow:0 4px 4px -2px rgba(0,0,0,.5)}.tab{width:100%;color:#fff;overflow:hidden}.tab-input{position:absolute;opacity:0;z-index:-1}.tab-label{display:flex;justify-content:space-between;padding:.5em;background:#161313;font-weight:bold;cursor:pointer}.tab-label:hover{background:#363945}.tab-label::after{content:"❯";width:1em;height:1em;text-align:center;transition:all .25s}.tab-content{max-height:0;padding:0 1em;color:#2c3e50;background:#161313;transition:all .35s}.tab-close{display:flex;justify-content:flex-end;padding:1em;font-size:.75em;background:#161313;cursor:pointer}.tab-close:hover{background:#363945}input:checked+.tab-label{background:#363945}input:checked+.tab-label::after{transform:rotate(90deg)}input:checked~.tab-content{display:block;max-height:100vh;padding:1em}.text-editor{margin:0px}.textbox{height:60vh;max-height:500px}html body{font-family:"Roboto",sans-serif;font-size:16px;line-height:1.15}#webgl-canvas{width:100%;height:100%;position:absolute;top:0;left:0;z-index:0}.side-bar-right{position:absolute;right:0;top:0;width:25%;height:calc(100vh);overflow-y:auto;background-color:rgba(0,0,0,0)}.float-right{float:right}.bd-light-purple{border-color:#a463f2}select{border-width:0px}.divider{border-top:.1rem solid #555}.model-loader-wrapper{display:flex;flex-direction:column}textarea{color:#d3d3d3;background-color:#161313}.cursor-pointer{cursor:pointer}@media screen and (max-width: 600px){.side-bar-right{position:absolute;bottom:0;width:100%;max-height:40%;height:initial;right:inherit;top:inherit}}',"",{version:3,sources:["webpack://./src/style/style.scss","webpack://./src/style/accordion.scss","webpack://./src/style/_variables.scss","webpack://./src/style/textWidget.scss"],names:[],mappings:"AAAA,MCEA,iBACI,CAAA,eACA,CAAA,wCACA,CAAA,KAEJ,UACI,CAAA,UACA,CAAA,eACA,CAAA,WACA,iBACI,CAAA,SACA,CAAA,UACA,CAAA,WAEJ,YACI,CAAA,6BACA,CAAA,YACA,CAAA,kBCnBG,CAAA,gBDqBH,CAAA,cACA,CAAA,iBAEA,kBCvBE,CAAA,kBD0BF,WACI,CAAA,SACA,CAAA,UACA,CAAA,iBACA,CAAA,mBACA,CAAA,aAGR,YACI,CAAA,aACA,CAAA,aChCK,CAAA,kBALF,CAAA,mBDwCH,CAAA,WAEJ,YACI,CAAA,wBACA,CAAA,WACA,CAAA,eACA,CAAA,kBC9CG,CAAA,cDgDH,CAAA,iBACA,kBChDE,CAAA,yBDwDN,kBCxDM,CAAA,gCD0DF,uBACI,CAAA,2BAGR,aACI,CAAA,gBACA,CAAA,WACA,CAAA,aElER,UACI,CAAA,SAGJ,WACI,CAAA,gBACA,CAAA,UHFJ,+BACE,CAAA,cACA,CAAA,gBACA,CAAA,cAGF,UACE,CAAA,WACA,CAAA,iBACA,CAAA,KACA,CAAA,MACA,CAAA,SACA,CAAA,gBAGF,iBACE,CAAA,OACA,CAAA,KACA,CAAA,SACA,CAAA,kBACA,CAAA,eACA,CAAA,8BEtBe,CAAA,aF0BjB,WACE,CAAA,iBAGF,oBE1Be,CAAA,OF8Bf,gBACE,CAAA,SAGF,2BACE,CAAA,sBAGF,YACE,CAAA,qBACA,CAAA,SAGF,aE5CkB,CAAA,wBANP,CAAA,gBFuDX,cACE,CAAA,qCAGF,gBACE,iBACE,CAAA,QACA,CAAA,UACA,CAAA,cACA,CAAA,cACA,CAAA,aACA,CAAA,WACA,CAAA",sourcesContent:['@import "./variables";\n@import "./accordion.scss";\n@import "./textWidget.scss";\n\nhtml body {\n  font-family: \'Roboto\', sans-serif;\n  font-size: 16px;\n  line-height: 1.15;\n}\n\n#webgl-canvas {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 0;\n}\n\n.side-bar-right {\n  position:absolute;\n  right: 0;\n  top: 0;\n  width: 25%;\n  height: calc(100vh);\n  overflow-y: auto;\n  background-color: $bg-transparent;\n}\n\n.float-right {\n  float: right;\n}\n\n.bd-light-purple {\n  border-color: $light-purple;\n}\n\nselect {\n  border-width: 0px;\n}\n\n.divider {\n  border-top: 0.1rem solid $light-grey;\n}\n\n.model-loader-wrapper {\n  display: flex;\n  flex-direction: column;\n}\n\ntextarea {\n  color: $font-light-gray;\n  background-color: $bg-black;\n}\n\n.cursor-pointer {\n  cursor: pointer\n}\n\n@media screen and (max-width: 600px) {\n  .side-bar-right {\n    position: absolute;\n    bottom: 0;\n    width: 100%;\n    max-height: 40%;\n    height: initial;\n    right: inherit;\n    top: inherit;\n  }\n}\n','\n/* Accordion styles */\n.tabs {\n    border-radius: 0px;\n    overflow: hidden;\n    box-shadow: 0 4px 4px -2px rgba(0,0,0,0.5);\n  }\n.tab {\n    width: 100%;\n    color: white;\n    overflow: hidden;\n    &-input {\n        position: absolute;\n        opacity: 0;\n        z-index: -1;\n    }\n    &-label {\n        display: flex;\n        justify-content: space-between;\n        padding: 0.5em;\n        background: $bg-black;\n        font-weight: bold;\n        cursor: pointer;\n        /* Icon */\n        &:hover {\n            background: $bg-grey;\n        }\n        &::after {\n            content: "\\276F";\n            width: 1em;\n            height: 1em;\n            text-align: center;\n            transition: all .25s;\n        }\n    }\n    &-content {\n        max-height: 0;\n        padding: 0 1em;\n        color: $font-black;\n        background: $bg-black;\n        transition: all .35s;\n    }\n    &-close {\n        display: flex;\n        justify-content: flex-end;\n        padding: 1em;\n        font-size: 0.75em;\n        background: $bg-black;\n        cursor: pointer;\n        &:hover {\n            background: $bg-grey;\n        }\n    }\n}\n  \n// :checked\ninput:checked {\n    + .tab-label {\n        background: $bg-grey;\n        &::after {\n            transform: rotate(90deg);\n        }\n    }\n    ~ .tab-content {\n        display:block;\n        max-height: 100vh;\n        padding: 1em;\n    }\n}',"$bg-black: #161313;\n$bg-grey: #363945;\n$bg-black-trasparent: rgba(54, 57, 69, 0.7);\n$bg-transparent: rgba(0, 0, 0, 0);\n$font-white: #FFFFFF;\n$font-black: #2c3e50;\n$font-light-gray: lightgray;\n$light-purple: #a463f2;\n$light-grey: #555;\n",".text-editor {\n    margin: 0px;\n}\n\n.textbox {\n    height: 60vh;\n    max-height: 500px;\n}"],sourceRoot:""}]);const c=a},3645:n=>{"use strict";n.exports=function(n){var e=[];return e.toString=function(){return this.map((function(e){var t=n(e);return e[2]?"@media ".concat(e[2]," {").concat(t,"}"):t})).join("")},e.i=function(n,t,o){"string"==typeof n&&(n=[[null,n,""]]);var r={};if(o)for(var i=0;i<this.length;i++){var a=this[i][0];null!=a&&(r[a]=!0)}for(var c=0;c<n.length;c++){var s=[].concat(n[c]);o&&r[s[0]]||(t&&(s[2]?s[2]="".concat(t," and ").concat(s[2]):s[2]=t),e.push(s))}},e}},4015:n=>{"use strict";function e(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}n.exports=function(n){var t,o,r=(o=4,function(n){if(Array.isArray(n))return n}(t=n)||function(n,e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(n)){var t=[],o=!0,r=!1,i=void 0;try{for(var a,c=n[Symbol.iterator]();!(o=(a=c.next()).done)&&(t.push(a.value),!e||t.length!==e);o=!0);}catch(n){r=!0,i=n}finally{try{o||null==c.return||c.return()}finally{if(r)throw i}}return t}}(t,o)||function(n,t){if(n){if("string"==typeof n)return e(n,t);var o=Object.prototype.toString.call(n).slice(8,-1);return"Object"===o&&n.constructor&&(o=n.constructor.name),"Map"===o||"Set"===o?Array.from(n):"Arguments"===o||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o)?e(n,t):void 0}}(t,o)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()),i=r[1],a=r[3];if("function"==typeof btoa){var c=btoa(unescape(encodeURIComponent(JSON.stringify(a)))),s="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(c),l="/*# ".concat(s," */"),u=a.sources.map((function(n){return"/*# sourceURL=".concat(a.sourceRoot||"").concat(n," */")}));return[i].concat(u).concat([l]).join("\n")}return[i].join("\n")}},3379:(n,e,t)=>{"use strict";var o,r=function(){var n={};return function(e){if(void 0===n[e]){var t=document.querySelector(e);if(window.HTMLIFrameElement&&t instanceof window.HTMLIFrameElement)try{t=t.contentDocument.head}catch(n){t=null}n[e]=t}return n[e]}}(),i=[];function a(n){for(var e=-1,t=0;t<i.length;t++)if(i[t].identifier===n){e=t;break}return e}function c(n,e){for(var t={},o=[],r=0;r<n.length;r++){var c=n[r],s=e.base?c[0]+e.base:c[0],l=t[s]||0,u="".concat(s," ").concat(l);t[s]=l+1;var f=a(u),v={css:c[1],media:c[2],sourceMap:c[3]};-1!==f?(i[f].references++,i[f].updater(v)):i.push({identifier:u,updater:p(v,e),references:1}),o.push(u)}return o}function s(n){var e=document.createElement("style"),o=n.attributes||{};if(void 0===o.nonce){var i=t.nc;i&&(o.nonce=i)}if(Object.keys(o).forEach((function(n){e.setAttribute(n,o[n])})),"function"==typeof n.insert)n.insert(e);else{var a=r(n.insert||"head");if(!a)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");a.appendChild(e)}return e}var l,u=(l=[],function(n,e){return l[n]=e,l.filter(Boolean).join("\n")});function f(n,e,t,o){var r=t?"":o.media?"@media ".concat(o.media," {").concat(o.css,"}"):o.css;if(n.styleSheet)n.styleSheet.cssText=u(e,r);else{var i=document.createTextNode(r),a=n.childNodes;a[e]&&n.removeChild(a[e]),a.length?n.insertBefore(i,a[e]):n.appendChild(i)}}function v(n,e,t){var o=t.css,r=t.media,i=t.sourceMap;if(r?n.setAttribute("media",r):n.removeAttribute("media"),i&&"undefined"!=typeof btoa&&(o+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(i))))," */")),n.styleSheet)n.styleSheet.cssText=o;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(o))}}var m=null,d=0;function p(n,e){var t,o,r;if(e.singleton){var i=d++;t=m||(m=s(e)),o=f.bind(null,t,i,!1),r=f.bind(null,t,i,!0)}else t=s(e),o=v.bind(null,t,e),r=function(){!function(n){if(null===n.parentNode)return!1;n.parentNode.removeChild(n)}(t)};return o(n),function(e){if(e){if(e.css===n.css&&e.media===n.media&&e.sourceMap===n.sourceMap)return;o(n=e)}else r()}}n.exports=function(n,e){(e=e||{}).singleton||"boolean"==typeof e.singleton||(e.singleton=(void 0===o&&(o=Boolean(window&&document&&document.all&&!window.atob)),o));var t=c(n=n||[],e);return function(n){if(n=n||[],"[object Array]"===Object.prototype.toString.call(n)){for(var o=0;o<t.length;o++){var r=a(t[o]);i[r].references--}for(var s=c(n,e),l=0;l<t.length;l++){var u=a(t[l]);0===i[u].references&&(i[u].updater(),i.splice(u,1))}t=s}}}},7896:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/cubemap_building/face0.png"},8226:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/cubemap_building/face1.png"},7035:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/cubemap_building/face2.png"},9684:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/cubemap_building/face3.png"},7933:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/cubemap_building/face4.png"},6141:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/cubemap_building/face5.png"},3674:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/cubemap_forest/face0.png"},4240:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/cubemap_forest/face1.png"},4013:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/cubemap_forest/face2.png"},6359:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/cubemap_forest/face3.png"},4900:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/cubemap_forest/face4.png"},1297:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/cubemap_forest/face5.png"},2742:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/models/chemodan/suitcase.obj"},4200:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/models/chemodan/textures/ao.jpg"},4370:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/models/chemodan/textures/color.jpg"},3111:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/models/chemodan/textures/metallic.jpg"},6871:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/models/chemodan/textures/normal.jpg"},8109:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/models/chemodan/textures/roughness.jpg"},600:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/models/coffee_cup/coffee_cup_obj.obj"},4475:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/models/coffee_cup/textures/Base_color.png"},4732:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/models/coffee_cup/textures/metallic.png"},4470:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/models/coffee_cup/textures/normal.png"},9243:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/models/coffee_cup/textures/roughness.png"},8014:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/models/cube.obj"},7811:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/textures/brickwall.jpg"},8216:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/textures/brickwall_normal.jpg"},4003:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/textures/cobble.png"},6524:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/textures/noise256.png"},8893:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/textures/noise64.png"},6307:(n,e,t)=>{"use strict";n.exports=t.p+"src/external/textures/wood.png"}},e={};function t(o){if(e[o])return e[o].exports;var r=e[o]={id:o,exports:{}};return n[o](r,r.exports,t),r.exports}t.n=n=>{var e=n&&n.__esModule?()=>n.default:()=>n;return t.d(e,{a:e}),e},t.d=(n,e)=>{for(var o in e)t.o(e,o)&&!t.o(n,o)&&Object.defineProperty(n,o,{enumerable:!0,get:e[o]})},t.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),t.p="./",(()=>{"use strict";var n=t(3379),e=t.n(n),o=t(4578);e()(o.Z,{insert:"head",singleton:!1}),o.Z.locals;var r=t(9713),i=t.n(r),a=t(8),c=t.n(a),s=t(319),l=t.n(s);const u={vertex:"#version 300 es\n  precision mediump float;\n  in vec4 a_position;\n  in vec2 a_texCoord;\n  in vec3 a_normal;\n  out vec2 v_texCoord;\n  out vec3 v_normal;\n\n  void main(){\n    gl_Position = a_position;\n    v_texCoord = a_texCoord;\n    v_normal = a_normal;\n  }\n",fragment:"#version 300 es\nprecision mediump float;\nuniform sampler2D u_sample;\nuniform sampler2D u_depth;\nuniform float u_near;\nuniform float u_far;\nuniform float u_fog;\nuniform vec3 u_fogColor;\nin vec2 v_texCoord;\nin vec3 v_normal;\nout vec4 outColor;\n\nfloat perspectiveDepth() {\n  vec4 texDepth = texture(u_depth, v_texCoord);\n  float depth = texDepth.r;\n  float z = depth * 2.0 - 1.0; // Back to NDC\n  float near = u_near;\n  float far = u_far;\n  depth = (2.0 * near * far) / (far + near - z * (far - near));\n  depth /= far;\n  return depth;\n}\n\nvoid main(){\n  vec2 uv = v_texCoord;\n  vec3 texColor = texture(u_sample, uv).rgb;\n  float depth = perspectiveDepth();\n  //float depth = texture(u_depth, uv).r;\n  //unfog skybox\n  // if (depth > 0.99) {\n  //   depth = 0.4;\n  // }\n  vec3 fogColor = u_fogColor / 255.0;\n  float b = u_fog;\n  float fogAmount = exp(-b*b*depth);\n  vec3 color = mix(fogColor, texColor, fogAmount);\n  outColor = vec4(color, 1.0);\n}\n"},f="#version 300 es\n  precision mediump float;\n  in vec4 a_position;\n  in vec2 a_texCoord;\n  in vec3 a_normal;\n  out vec2 v_texCoord;\n  out vec3 v_normal;\n  out vec4 v_fragPos;\n\n  void main(){\n    gl_Position = a_position;\n    v_texCoord = a_texCoord;\n    v_normal = a_normal;\n    v_fragPos = a_position;\n  }\n",v={vertex:f,fragment:"#version 300 es\nprecision mediump float;\nuniform sampler2D u_sample;\nuniform vec2 u_mouse;\nuniform float u_time;\nuniform vec2 u_resolution;\nin vec2 v_texCoord;\nin vec3 v_normal;\nin vec4 v_fragPos;\nout vec4 outColor;\n\nvoid main(){\n  vec3 color = texture(u_sample, v_texCoord+u_mouse/u_resolution).rgb;\n  outColor = vec4(color * vec3(v_texCoord+0.5*sin(u_time), 0.0), 1.0);\n}\n"},m={vertex:f,fragment:"#version 300 es\n    precision mediump float;\n\n    uniform vec2 u_mouse;\n    uniform float u_time;\n    uniform vec2 u_resolution;\n    \n    in vec2 v_texCoord;\n    in vec3 v_normal;\n    in vec4 v_fragPos;\n    out vec4 fragColor;\n\n    const float TURBULENCE = 0.04;\n    //noise function from iq: https://www.shadertoy.com/view/Msf3WH\n    vec2 hash( vec2 p ) \n    {\n        p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n        return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    }\n\n    float noise( in vec2 p )\n    {\n        const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n        const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n        vec2  i = floor( p + (p.x+p.y)*K1 );\n        vec2  a = p - i + (i.x+i.y)*K2;\n        float m = step(a.y,a.x); \n        vec2  o = vec2(m,1.0-m);\n        vec2  b = a - o + K2;\n        vec2  c = a - 1.0 + 2.0*K2;\n        vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n        vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n        return dot( n, vec3(70.0) );\n    }\n\n    const mat2 m2 = mat2(1.6,  1.2, -1.2,  1.6);\n\n    float fbm(vec2 p) {\n        float amp = 0.5;\n        float h = 0.0;\n        for (int i = 0; i < 8; i++) {\n            float n = noise(p);\n            h += amp * n;\n            amp *= 0.5;\n            p = m2 * p ;\n        }\n        \n        return  0.5 + 0.5*h;\n    }\n    vec3 smokeEffect(vec2 uv) {\n        vec3 col = vec3(0.0);\n        // time scale\n        float v = 0.0002;\n        vec3 smoke = vec3(1.0);\n        vec2 scale = uv * 0.5 ;\n        vec2 turbulence = TURBULENCE * vec2(noise(vec2(uv.x * 3.5, uv.y * 3.2)), noise(vec2(uv.x * 2.2, uv.y * 1.5)));\n        scale += turbulence;\n        float n1 = fbm(vec2(scale.x - abs(sin(u_time * v * 2.0)), scale.y - 50.0 * abs(sin(u_time * v))));\n        col =  mix( col, smoke, smoothstep(0.5, 0.9, n1));\n        col = clamp(col, vec3(0.0), vec3(1.0));\n        return col;\n    }\n\n    float circle(vec2 p, float r) {\n        float c = length(p) - r;\n        return smoothstep(r + 0.01, r, c);\n    }\n\n    float sinwave(vec2 p, float scale, float amp) {\n        float wave = cos(p.x * scale + 0.5) + 0.25 * cos(p.x * scale * scale);\n        float s = smoothstep(amp + 0.01, amp, amp * wave - p.y);\n        return s;\n    }\n\n    void main() {\n        vec2 uv = v_texCoord;\n        vec2 p = gl_FragCoord.xy/u_resolution;\n        p -= 0.5;\n        p.x *= u_resolution.x / u_resolution.y;\n\n        vec3 col = vec3(0.0);    \n        vec3 smoke = smokeEffect(p);\n        \n        vec3 background = 0.7 * vec3(238.0,232.0,170.0)/255.0;\n        vec3 mountCol = mix(vec3(102.0,153.0,153.0)/255.0, vec3(153.0,204.0,0.0)/255.0, p.y + 0.5);\n        vec3 sunCol = 0.85 * mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), p.y + 0.5);\n        vec3 cloudCol = vec3(0.9);\n        float t = u_time * 0.05;\n        vec2 sunPos = p - vec2(0.4 * cos(t), 0.4 * sin(t));\n        float sun = circle(sunPos, 0.1); \n        float mountain1 = sinwave(p - vec2(0.5, -0.1), 3.0, 0.1);\n        float mountain2 = sinwave(p, 3.0, 0.2);\n        float cloud = 1.0 - smoke.r;\n        col = mix(background, sunCol, sun);\n        col = mix(mountCol * 0.9, col, mountain1);\n        col = mix(cloudCol, col, cloud);\n        col = mix(mountCol, col, mountain2);\n        \n        col *= 0.2 + 0.8 * pow(32.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.2);\n        fragColor = vec4(col ,1.0);\n    }\n"},d={vertex:f,fragment:"#version 300 es\nprecision mediump float;\n\nuniform sampler2D u_sample;\nuniform vec2 u_mouse;\nuniform float u_time;\nuniform vec2 u_resolution;\nin vec2 v_texCoord;\nin vec3 v_normal;\nin vec4 v_fragPos;\nout vec4 fragColor;\n\n//#define TIME mod(iTime,10000.0)\n#define PI 3.1416\n#define TERRAIN_PATTERN 4.0*sin(12.0*pos.x)+sin(20.0*pos.y)+sin(15.0*pos.z)\n#define SPEED aTime*0.3\n#define MAX_DIST 20.0\n#define MAX_STEP 80\n#define SUN_DIRECTION vec3(0.8,0.3,0.9)\n#define SUNLIGHT_INTENSITY vec3(6.0,5.5,4.0)\n#define SUNSET_COLOR vec3(0.7,0.2,0.1)\n#define SKY_COLOR vec3(0.25, 0.35, 0.6)\n#define TERRAIN_COLOR vec3(0.07,0.04,0.03)\n#define RIM_COLOR vec3(0.85,0.1,0.1)\n#define RIM_POWER 0.15\n#define AA_SIZE 0\n\n#define iTime u_time\n#define iMouse u_mouse\n#define iResolution u_resolution\n\nfloat hash1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 0.013);\n    p3 += dot(p3, p3.yzx + 19.31);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return k0 + k1*u.x + k2*u.y + k4*u.x*u.y;\n}\n\nfloat sdSphere(in vec3 pos, in float r)\n{\n    return length(pos)-r;\n}\n\n//http://iquilezles.org/www/articles/ellipsoids/ellipsoids.htm\nfloat sdElipsoid(in vec3 pos, in vec3 r)\n{\n    float k0 = length(pos/r);\n    float k1 = length(pos/r/r);\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float r = mix(r1, r2, h);\n\treturn length( pa - ba*h ) - r;\n}\n\n//http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(in float a, in float b, in float k)\n{\n    float h = max( k - abs(a-b), 0.0);\n    return min(a,b) - h*h*0.25/k;\n}\n\nvec4 sdUnion(vec4 d1, vec4 d2)\n{\n    return (d1.x<d2.x)? d1:d2;\n}\n\nvec4 map(in vec3 pos, float aTime)\n{\n    vec4 res = vec4(0.0, 0.0, 0.0, 0.0);\n    float t = fract(aTime);\n    float y = 3.0*t*(1.0-t); \n    vec3 cen = vec3(0.0,0.25+0.01*y,SPEED);\n    float sy = 0.8 + 0.2*y;\n    float sz = 1.0/sy;\n    vec3 r = vec3(0.35,0.32+0.02*sy,0.25+0.05*sz);\n    vec3 q = pos-cen;\n    vec3 h = q;\n    \n    //body\n    float d = sdElipsoid(q-vec3(0.0, 0.03, -0.09), r);\n    \n  \n    {\n    \n    //head\n    float hr = sin(aTime);\n    hr = 0.5*sign(hr)*smoothstep(0.5,1.0,abs(hr));\n    h.xz = mat2(cos(hr),sin(hr),-sin(hr),cos(hr))*h.xz;\n    \n    float d1 = sdElipsoid(h - vec3(0.0, 0.32, 0.01), vec3(0.28, 0.2, 0.18));\n    float d2 = sdElipsoid(h - vec3(0.0, 0.30, -0.07), vec3(0.2));\n    d2 = smin(d1, d2, 0.08);\n    d = smin(d, d2, 0.08);\n    \n    \n    vec3 sh = vec3(abs(h.x), h.yz);//symmetric along x\n    \n    //legs\n    vec3 shh = vec3(abs(h.x), h.y, abs(h.z+0.1));//symmetric along x and z\n    //animation settings\n    float t1 = fract(aTime+4.71*sign(h.x));\n    float y1 = 3.0*t1*(1.0-t1); \n    float offset = y1;\n    \n    d1 = sdStick(shh - vec3(0.11,-0.24,0.22), vec3(0.0,0.18,-0.1), vec3(0.0,-0.1,-0.15*offset), 0.08, 0.05); \n    d = smin(d, d1, 0.04);\n        \n    //nose\n    d1 = sdStick(h, vec3(0.0,0.41,0.12), vec3(0.0,0.37,0.18), 0.05, 0.03);\n    d = smin(d,d1,0.01);\n    \n    //ears\n    d2 = sdElipsoid(sh - vec3(0.15, 0.47, -0.05), vec3(0.06, 0.09, 0.04));\n    d = smin(d, d2, 0.08);\n    res = vec4(d,2.0,0.0,0.0);\n    \n    //tail\n    d2 = sdStick(h, vec3(0.0,-0.3,-0.1), vec3(-0.1*y,0.2,-0.55), 0.03, 0.05);\n    d = smin(d, d2, 0.06);\n    res = vec4(d,2.0,0.0,0.0);\n    \n    \n    //eyelids\n    vec3 elPos = sh - vec3(0.04,0.33,0.09);\n    d2 = sdStick(elPos, vec3(0.0,0.12,0.02), vec3(0.05,0.1,-0.02), 0.02, 0.02);\n   \td = smin(d, d2, 0.03);\n    res = vec4(d,2.0,0.0,0.0);\n    \n     \n    //eyes\n    float d5 = sdSphere(sh - vec3(0.065,0.4,0.108), 0.07);\n    res = sdUnion(res, vec4(d5,3.0,0.0,0.0));\n    \n    float eyeOffsetY = 0.01*smoothstep(0.0, 0.8,sin(aTime));\n    \n    d5 = sdSphere(sh - vec3(0.066,0.40+eyeOffsetY,0.124), 0.056);\n    res = sdUnion(res, vec4(d5,4.0,0.0,0.0));\n         \n    //mouth\n    float d6 = sdElipsoid(h - vec3(0.0,0.29,0.16), vec3(0.06,0.03,0.04));\n    float d7 = sdElipsoid(sh - vec3(0.035,0.32,0.175), vec3(0.055,0.036,0.04));\n    d6 = smin(d6,d7,0.01);\n    res = sdUnion(res, vec4(d6,6.0,0.0,0.0));\n    \n    //terrain\n    float fh = -0.1+0.05*(sin(2.2*pos.x) + sin(1.5*pos.z));\n    d1 = pos.y - fh;\n    d1 -= .01*noise(vec2(pos.x*10.0,pos.z*10.0));\n    if (d1<res.x) res = vec4(d1,1.0,0.0,0.0);\n    \n    //watermelon\n    float b = 5.0;\n    vec3 rep = vec3(mod(abs(pos.x),b)-3.5, pos.y, mod(abs(pos.z+1.5), b)-2.5);\n    vec2 id = vec2(floor(abs(pos.x)/b),floor((pos.z+1.5)/b));\n    float fid = id.x*13.3 + id.y*31.7;\n    float wr = 1.4+0.5*sin(fid*1.312);\n    \n    d2 = sdSphere(rep, wr);\n    if (d2<res.x) res = vec4(d2,8.0,0.0,0.0);\n \n    }\n    return res;\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float aTime)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float h = 0.01 + 0.16*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, aTime ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        \n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 calcNormal(in vec3 pos, in float aTime)\n{\n    vec2 e = vec2(0.001,0.0);\n    return normalize( vec3(map(pos + e.xyy,aTime).x - map(pos - e.xyy,aTime).x,\n                          map(pos + e.yxy,aTime).x - map(pos - e.yxy,aTime).x,\n                          map(pos + e.yyx,aTime).x - map(pos - e.yyx,aTime).x) );\n}\n\nfloat castShadow(in vec3 ro, in vec3 rd, in float aTime)\n{\n    float res = 1.0;\n    float t = 0.01;\n    float tMax = MAX_DIST;\n\n    for (int i=0; i<MAX_STEP;++i)\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos,aTime).x;\n        res = min( res, 18.0*h/t );\n        if (res<0.001) break;\n        t += h;\n        if (t>tMax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec4 castRay(in vec3 ro, in vec3 rd, in float aTime)\n{\n   float t = 0.01;\n   vec3 m = vec3(0.0);\n   float tMax = MAX_DIST;\n   /*\n   float hMax = 2.5;\n   float bt = (hMax-ro.y)/rd.y;\n   if ( bt>0.0 ) tMax = min(tMax, bt);\n   */\n   \n   for ( int i = 0; i < MAX_STEP; ++i )\n   {\n       vec3 pos = ro + t*rd;\n       vec4 h = map( pos,aTime );\n       m = h.yzw;\n       if ( abs(h.x)<(0.001*t) )\n       {\n           break;\n       }\n       t += h.x;\n       if ( t>tMax ) break;\n   } \n    \n   if ( t>tMax )\n   {\n       m = vec3(-1.0);\n   }\n   return vec4(t,m);\n}\n\nvec3 render(in vec2 fragCoord, in float aTime)\n{\n    vec2 p = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float angle = 10.0*iMouse.x/iResolution.x+1.0;\n    \n    vec3 ta = vec3(0.0,0.45,0.8+SPEED);\n    vec3 ro = ta+vec3( 1.0*cos(angle), mouse.y, 1.0*sin(angle) );;\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize( cross( ww, vec3(0.0, 1.0, 0.0) ) );\n    vec3 vv = normalize( cross( uu, ww ) );\n    \n    \n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0*ww);\n    vec3 sunDir = SUN_DIRECTION;//normalize( vec3(0.8,0.4,0.9) );\n    \n    vec3 col = SKY_COLOR;\n    \n    vec2 uv = rd.xz/rd.y; //sky dome( intersect the top )\n    float sinV = 1.0*(sin(1.0*uv.x )+sin(1.0*uv.y))\n        \t\t+ 0.5*(sin(2.0*uv.x+aTime)+sin(2.0*uv.y+aTime));\n    col = mix( col, vec3(0.9,0.85,0.6),smoothstep(-0.3,0.3,-0.5+sinV) );\n    col = mix(col, SUNSET_COLOR, exp(-4.0*rd.y));\n   \n    vec4 tm = castRay(ro, rd, aTime);\n    if ( tm.y>-1.0 )\n    {\n        float t = tm.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, aTime);\n        vec3 mate = vec3(0.18);\n        if (tm.y==8.0)\n        {\n            //watermelon\n            mate = vec3(0.03,0.1,0.07);\n            float f = 1.0-smoothstep(-0.2, 0.2, TERRAIN_PATTERN);\n            mate = mix(mate, vec3(0.0,0.05,0.03), f);\n        } \n        else if (tm.y==7.0)\n        {\n            mate = vec3(0.8,0.2,0.0);\n        }\n        else if (tm.y==6.0)\n        {\n            mate = vec3(0.2,0.2,0.2); //mouth\n        }\n        else if (tm.y==5.0)\n        {\n            mate = vec3(0.25)*pos.y; //tail\n        } \n        else if (tm.y==4.0)\n        {\n        \tmate = vec3(0.01, 0.01, 0.015); //eyes \n        }\n        else if (tm.y==3.0)\n        {\n            mate = vec3(0.5, 0.5, 0.5); //eyes\n        }\n        else if (tm.y==2.0)\n        {\n            mate = vec3(0.01,0.01,0.02);//body\n        } else\n        {\n            mate = TERRAIN_COLOR;//terrain\n        }\n        \n        float occ = calcOcclusion( pos, nor, aTime );\n        float fresnel = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float sunDiff = clamp( dot(nor, sunDir),0.0,1.0 );\n        float sunShadow = castShadow(pos+nor*0.01, sunDir, aTime);//step( castRay(pos+nor*0.001, sunDir).y,0.0 );\n        float skyDiff = clamp( 0.5 + 0.5*dot(nor, vec3(0.0,1.0,0.0)),0.0,1.0 );\n        //Simulate how lights bounce off from the ground to the object surface.\n        float bounceDiff = clamp( 0.5 + 0.5*dot(nor, vec3(0.0,-1.0,0.0)),0.0,1.0 );\n        col = mate*SUNLIGHT_INTENSITY*sunDiff*sunShadow;\n        col += mate*SKY_COLOR*skyDiff;\n        col += mate*SUNSET_COLOR*bounceDiff;\n        col *= occ;\n        col += RIM_POWER*RIM_COLOR*fresnel;\n        \n        if (tm.y==4.0 || tm.y==8.0)\n        {\n            vec3 viewDir = normalize(ro-pos);\n            vec3 reflectDir = normalize(reflect(-sunDir, nor));\n            float spec = pow(max(dot(reflectDir, viewDir), 0.0), 64.0);\n            vec3 speCol = vec3(1.0) * spec;\n            col += speCol;\n        }\n        \n        // fog\n        col = mix( col, SUNSET_COLOR, 1.0-exp( -0.005*t*t ) );\n    } \n    return col;\n}\n\nvoid main()\n{\n    vec3 col = vec3(0.0);\n    vec2 off = vec2(0.0);\n    vec2 fragCoord = gl_FragCoord.xy;\n    float md = texture(u_sample, fragCoord).x;\n    \n#if AA_SIZE>1\n    //anti aliasing & motion blur\n    for (float aaY = 0.0; aaY < float(AA_SIZE); ++aaY)\n    {\n        for (float aaX = 0.0; aaX < float(AA_SIZE); ++aaX)\n        {\n            off = -0.5+vec2(aaY,aaX)/float(AA_SIZE);\n            float mb = (aaY*float(AA_SIZE)+aaX)/(float(AA_SIZE*AA_SIZE-1));\n            mb += (md-0.5)/float(AA_SIZE*AA_SIZE);\n            float aTime = iTime - mb*0.5*(1.0/24.0); //1 frame in 24fps for film\n#else\n            float aTime = iTime;\n#endif\n            \n            col += render(fragCoord+off, aTime);\n            \n#if AA_SIZE>1\n        }\n    }\n    col /= float(AA_SIZE*AA_SIZE);\n#endif\n    \n    //gamma\n    col = pow( col, vec3(0.4546));\n    // vignetting        \n    vec2 q = v_texCoord;\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n    fragColor = vec4(col, 1.0);\n}\n"},p={vertex:f,fragment:"#version 300 es\n    precision mediump float;\n\n    uniform sampler2D u_sample;\n    uniform vec2 u_mouse;\n    uniform float u_time;\n    uniform vec2 u_resolution;\n    \n    in vec2 v_texCoord;\n    in vec3 v_normal;\n    in vec4 v_fragPos;\n    out vec4 fragColor;\n\n    #define iTime u_time\n    #define iMouse u_mouse\n    #define iResolution u_resolution\n\n    /*\nhttp://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm\nhttp://www.iquilezles.org/www/articles/morenoise/morenoise.htm\n*/\n\nconst vec3 PURPLE = vec3(1.0, 0.9, 1.0);//vec3(141.0, 0.0, 196.0)/255.0;\nconst vec3 PINK = vec3(0.5, 0.4, 0.4);//vec3(255.0,192.0,203.0)/255.0;\nconst vec3 WHITE = vec3(1.0);\nconst vec3 BLACK = vec3(0.0);\nconst vec3 SKY = vec3(0.0);\nconst vec3 MOON = vec3(1.0, 0.6, 0.0);\nconst vec3 BLUE = vec3(0.1,0.2,0.3);\nconst vec3 GREEN = vec3(0.1,0.2,0.3);\nconst vec3 EARTH = vec3(0.1);\nconst float PI = 3.1415926;\nconst float EPSILON = 0.0001;\nconst float SCALE = 0.01;\nconst float HEIGHT = 12.0;\nconst float MAX_DISTANCE = 400.0;\nconst int MAX_STEP = 40;\nconst int ITERATION = 8;\nconst float LUCUNARITY = 1.2;\n#define AA 1\n\nvec3 moonDir = normalize(vec3(7.0, 1.0, -5.0));\n\nfloat hash1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 0.013);\n    p3 += dot(p3, p3.yzx + 19.31);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return k0 + k1*u.x + k2*u.y + k4*u.x*u.y;\n}\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0 + 2.0 * (k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                      2.0* du * vec2( k1 + k4*u.y,\n                                      k2 + k4*u.x ) );\n}\n\nconst mat2 m2 = mat2(1.2,  0.8, -0.8,  1.2);\nfloat fbm4(vec2 p) {\n    float amp = 1.0;\n    float h = 0.0;\n    for (int i = 0; i < ITERATION; i++) {\n        float n = noise(p);\n        h += amp * n;\n        amp *= 0.5;\n        p = m2 * p ;\n    }\n\treturn  h;\n}\n\n\nconst mat2 m = mat2(1.2, -0.6, 0.6, 1.2);\nvec4 fbmd4(vec2 v) {\n    \n    float amp = 1.0;\n    float f = 1.0 ;\n    float h = 0.0;\n    vec2 d = vec2(0.0);\n    for (int i = 0; i < ITERATION; i++) {\n        vec3 n = 1.0 - abs(noised(v * SCALE * f)); //noised(v * SCALE * f)\n        h += amp * n.x;\n        d += amp * n.yz * f;\n        amp *= 0.5;\n        f *= LUCUNARITY;\n        v = m * v;\n    }\n    h *= HEIGHT  ;\n\td *= HEIGHT * SCALE;\n\treturn vec4( h, normalize( vec3(-d.x,1.0,-d.y) ) );\n}\n\nvec4 terrainMap(vec3 v) {\n    vec4 terrain = fbmd4(v.xz - vec2(100.0, 0.0));\n    terrain.x += .02*noise(v.xz*0.8);\n    return terrain;\n}\n\n    \nvec4 sceneMap(vec3 v) {\n    return terrainMap(v);\n}\n\nvec3 getNormal(vec3 p )\n{\n    vec2 OFFSET = vec2(EPSILON, 0.0);\n    return normalize( vec3( sceneMap(p-OFFSET.xyy).x-sceneMap(p+OFFSET.xyy).x,\n                            1.0*EPSILON,\n                            sceneMap(p-OFFSET.yyx).x-sceneMap(p+OFFSET.yyx).x ) );\n}\nvec3 moon(vec3 ro, vec3 rd) {\n    float n1 = 0.3*noise(rd.xy * 20.0 - iTime);\n    float n2 = 0.3*noise(rd.xy * 10.0 - iTime);\n    float sdot = dot(rd, moonDir)*10.0;\n    float m1 = smoothstep(9.4, 9.75, sdot);\n    float col1 = pow(m1, 128.0);\n    float m2 = smoothstep(9.0+n1, 9.75, sdot);\n    float col2 = pow(m2, 64.0);\n    float m3 = smoothstep(8.2+n2, 9.7, sdot);\n    float col3 = pow(m3, 32.0);\n    float hole1 = (col2 -col1);\n    float hole2 = (col3 -col1);\n    vec3 rst = hole1*MOON*8.0 + hole2*BLUE*2.0;\n    return rst;\n}\n\n\nvec3 stars(vec2 p) {\n    float t = iTime * 0.1;\n    float n1 = hash1(p*0.1) ;\n    n1 *= pow(n1*n1, 680.0) ;\n    n1 *= sin(t*5.0 + p.x + sin(t*2.0 + p.y));\n    n1 = clamp(n1, 0.0, 1.0);\n    return n1 * vec3(1.0);\n}\n\nvec3 sky(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    vec3 v = ro + rd*MAX_DISTANCE;\n    float n1 = noise(v.xy * 0.001);\n    float n2 = noise(v.yx * 0.001);\n    vec3 skyCol = GREEN * 0.01;\n    col += mix(skyCol, GREEN, exp(-16.0*v.y/MAX_DISTANCE));\n    col += stars(v.xy);\n    col += moon(ro, rd);\n    return col;\n}\n\nvec4 castRay(vec3 ro, vec3 rd) {\n    vec4 re = vec4(-1.0);\n    float t = 0.0;\n    for( int i=0; i<MAX_STEP; i++ ){\n        vec3 p = ro + rd * t;\n        vec4 n = sceneMap(p);\n        float h = p.y - n.x;\n    \tre = vec4(t, n.yzw);\n        t += h*n.z; \n        if ((abs(h) < EPSILON) || t > MAX_DISTANCE) {\n            break;\n        } \n    }\n    \n    if (t > MAX_DISTANCE) {\n        re = vec4(-1.0);\n    }\n    return re;\n}\n\nvec3 getShading(vec3 ro, vec3 rd, vec3 p, vec3 normal, vec3 color) {\n    vec3 col = vec3(0.0);\n    vec3 lightDir = moonDir;\n    float moonAmount = max(dot(rd, lightDir), 0.0);\n    vec3 lightCol = mix( GREEN, MOON, pow(moonAmount, 2.0));\n    \n    vec3 viewDir = normalize(ro - p); \n    vec3 refDir = reflect(-lightDir, normal);\n    \n    vec3 ambCol = lightCol * 0.1;\n    float diff = max(dot(lightDir, normal), 0.0);\n    vec3 diffCol = lightCol * diff;\n    \n    float spec = pow(max(dot(refDir, viewDir), 0.0), 8.0);\n    vec3 speCol = lightCol * spec * 0.7;\n    \n    \n    \n    col = (speCol + diffCol) * color ;\n    return col;\n}\n\nvec3 getMaterial(vec3 ro, vec3 rd, vec3 p, vec3 normal) {\n    //vec3 col = texture(iChannel1, p.xz * 0.0051, - 100.0).xyz * 0.5;\n    vec3 col = vec3(0.3, 0.1, 0.1);\n    vec3 lightDir = moonDir;\n    //a bit of sprinkling\n    if (hash1(p.xz) > 0.995) {\n    \tcol += clamp(sin(iTime + p.x*p.z), 0.5, 1.0) * vec3(1.2);\n  \t}\n    \n    return col;\n}\n\nvec3 terrainColor(vec3 ro, vec3 rd, vec3 p, vec3 nor) {\n    vec3 col = vec3(0.0);\n    col = getMaterial(ro, rd, p, nor);\n    col = getShading(ro, rd, p, nor, col) ;\n    \n    return col;\n}\n\nvec3 fog(vec3 ro, vec3 rd, vec3 p, vec3 pixCol, float dis)\n{\n    vec3 lightDir = moonDir;\n    //base color and moonlight\n    vec3 fogCol = vec3(0.0);\n    float b  = 0.000005;\n    float fogAmount = 1.0 - exp( -dis*dis*b );\n    \n    float moonAmount = max(dot(rd, lightDir), 0.0);\n    vec3 mixFog = mix(GREEN, MOON*0.5, pow(moonAmount, 16.0));\n\tfogCol = mix( pixCol, mixFog, fogAmount );\n   \n    //adding density\n    float c = 0.001;\n    float b1 = 0.15;\n    float t = iTime ;\n    float v = 1.0;\n    vec3  denCol  = GREEN; \n    float density =  c * exp(-ro.y*b1) * (1.0 - exp(-dis*rd.y*b1 ))/(rd.y);\n    \n    float turb = fbm4(vec2(p.x*0.02+t*v, p.z*0.02+t*v));\n    density += 0.05*turb;\n    fogCol += mix( pixCol, denCol, density);\n    return fogCol;\n}\n\nmat3 getCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render( in vec2 fragCoord)\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy ;\n    //uv -= 0.5; // translate to the center of the screen\n    uv.x *= iResolution.x / iResolution.y; // restore aspect ratio\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    //define camera\n    vec3 ro = vec3 (cos(mouse.x * 6.28) * 10.0, 0.0, sin(mouse.x * 6.28) * 10.0);\n    vec3 ta = vec3 (0.0, 1.0, -2.0);\n    mat3 cam = getCamera(ro, ta, 0.0);\n\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n    \n    //draw scene\n   \tvec3 color = vec3(0.0);\n    vec4 hnor = castRay(ro, rd);\n    vec3 p = ro + rd * hnor.x;\n    \n    if (hnor.x > EPSILON) {\n        //vec3 nor = hnor.yzw + 0.01*hash1(p.xz * 5.0);\n        vec3 nor= getNormal(p) ;\n        color += terrainColor(ro, rd, p, nor);  \n        color = fog(ro, rd, p, color, hnor.x);\n    } else {\n        color += sky(ro, rd);\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pixCol = vec3(0.0);\n    vec2 offset = vec2(0.0);\n    \n#if AA>1\n    for (float y = 0.0; y < float(AA); ++y)\n    {\n        for (float x = 0.0; x < float(AA); ++x)\n        {\n            offset = -0.5 + vec2(x, y) / float(AA);\n\n        \tpixCol += render(fragCoord+offset);\n        }\n    }\n    pixCol /= float(AA*AA);\n#else\n    pixCol += render(fragCoord);\n#endif\n        \n    pixCol = pow( pixCol, vec3(1.0/2.2) );\n    \n    // Output to screen\n    fragColor = vec4(pixCol, 1.0);\n\t\n}\n\nvoid main() {\n    vec3 tex = texture(u_sample, v_texCoord).rgb;\n    mainImage(fragColor, gl_FragCoord.xy);\n}\n"},h={vertex:f,fragment:"#version 300 es\n    precision mediump float;\n\n    uniform sampler2D u_sample;\n    uniform sampler2D u_sample1;\n    uniform vec2 u_mouse;\n    uniform float u_time;\n    uniform vec2 u_resolution;\n    \n    in vec2 v_texCoord;\n    in vec3 v_normal;\n    in vec4 v_fragPos;\n    out vec4 fragColor;\n    // Convert to shadertoy namings\n    #define iMouse u_mouse\n    #define iResolution u_resolution\n    #define iTime u_time\n\n    #define MAX_DISTANCE 80.0\n    #define MAX_STEP 120\n    #define EPSILON 0.0001\n    #define PI 3.1415\n    #define RIM_COLOR vec3(0.1,0.05,0.2)\n    #define LIGHT_COLOR vec3(0.15,0.1,0.3)\n    #define LIGHT_DIR vec3(cos(iTime),1.0,sin(iTime))\n    #define SPHERE_COLOR vec3(0.2, 0.6, 1.0)\n    #define GLOW vec3(0.1, 0.8, 1.0)\n    \n\n    //http://iquilezles.org/www/articles/smin/smin.htm\n    vec3 sdMin (vec3 d1, vec3 d2)\n    {\n        return d1.x < d2.x ? d1 : d2;\n    }\n\n    vec3 sdMax (vec3 d1, vec3 d2)\n    {\n        return d1.x > d2.x ? d1 : d2;\n    }\n\n    float sdSmoothMin( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); \n    }\n\n\n    float smin(in float a, in float b, in float k)\n    {\n        float h = max( k - abs(a-b), 0.0);\n        return min(a,b) - h*h*0.25/k;\n    }\n\n    float smax(in float a, in float b, in float k)\n    {\n        float h = max( k - abs(a-b), 0.0);\n        return max(a,b) + h*h*0.25/k;\n    }\n\n    float sphereSDF(vec3 p, float r) \n    {\n        return length(p) - r;\n    }\n\n    float sdVerticalCapsule( vec3 p, float h, float r )\n    {\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n    }\n\n    float disp (vec3 p) \n    {\n        float n = texture(u_sample, p.xy+p.yz+p.xz).r;\n        return  (sin(p.z * 25.2 + 10.0*n) + sin(p.x * 28.9 + 10.0*n));\n    }\n\n    float disp1 (vec3 p)\n    {\n        //return (sin(p.x) + sin(p.z)) * sin(p.y);\n        return texture(u_sample1, p.xz*0.1).r;\n    }\n\n    float leg(vec3 p, float h, float r) \n    {\n        vec3 q = p-vec3(0.0,-1.0,0.0) ;\n        q.xz += 0.5*sin(q.y*0.3);\n        float scale = mix(1.0, 2.2, smoothstep(h-10.0,h, q.y));\n        r *= scale;\n        float d = sdVerticalCapsule(q, h, r);\n        d += 0.008*disp(q*0.5);\n        return d;\n    }\n\n    float shell(vec3 p, float r) \n    {\n        float t = iTime*0.1;\n        float scale = mix(0.6+0.2*sin(t), 2.2+0.8*sin(t), smoothstep(-1.2,2.5, -0.6*p.y));\n        r *= scale;\n        float s1 = sphereSDF(p , r);\n        s1 = abs(s1)-0.1;\n        \n        s1 += 0.18*disp1(p*2.3)*(0.5+0.5*sin(t)); // holes\n        s1 *= 0.5;\n        \n        float plane = dot(p, normalize(vec3(0.0,-1.0,0.0)))-3.65;\n        \n        //plane -= 0.08*disp1(p*8.0);;\n        float d = s1 > plane ? s1 : plane;\n        \n        return d;\n    }\n\n    mat3 getCamera( in vec3 ro, in vec3 ta) \n    {\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(0.0, 1.0, 0.0);\n        vec3 cu = normalize( cross(cw,cp) );\n        vec3 cv =          ( cross(cu,cw) );\n        return mat3( cu, cv, cw );\n    }\n\n\n    float noise(in vec2 uv) {\n        return texture(u_sample1, uv/64.0).r;\n    }\n\n    float smoothNoise(in vec2 uv) {\n        vec2 luv = fract(uv); //range from 0.0 to 1.0\n        vec2 id = floor(uv); //the integer part of uv, 0, 1, 2\n        luv = luv*luv*(3.0 - 2.0*luv); //similar to smoothstep\n        \n        //get values from the cordinates of a square\n        float bl = noise(id);\n        float br = noise(id + vec2(1.0, 0.0));\n        float tl = noise(id + vec2(0.0, 1.0));\n        float tr = noise(id + vec2(1.0, 1.0));\n        \n        float b = mix(bl, br, luv.x); //interpolate between bl and br\n        float t = mix(tl, tr, luv.x); //interpolate between tl and tr\n        \n        return mix(b, t, luv.y);\n    }\n\n    float hash21(vec2 p) {\n        p = fract(p*vec2(133.7, 337.1));\n        p += dot(p, p+vec2(37.1,17.33));\n        return fract(p.x*p.y);\n    }\n\n    vec3 offset = vec3(0.0);\n    vec4 sceneSDF(vec3 p) \n    {\n        \n        vec3 q = p; // org pos\n        \n        //head\n        float d1 = shell(q, 3.5);\n        \n        //leg\n        float h = 15.0;\n        float r = 0.9;\n        vec3 q1 = q - vec3(0.0, -h, 0.0);\n        float d2 = leg(q1, h, r);\n        \n        //ground\n        float d3 = q1.y + 2.0*texture(u_sample1, q1.xz*0.01).r;\n        \n        float d = sdSmoothMin(d1, d2, 0.5);\n        d = sdSmoothMin(d, d3, 2.0);\n        vec3 rst = vec3(d, 1.0, 0.0);\n        \n        //glow\n        float v = 0.2;\n        vec3 npos = v*(p-vec3(0.0, -h-1.0, 0.0));\n        vec2 nid = floor(vec2(npos.x+0.5, npos.z+0.5));\n        vec3 fid = vec3(fract(npos.x+0.5)-0.5, npos.y, fract(npos.z+0.5)-0.5);\n        float nn = hash21(nid*3.0);\n        vec3 fpos = fid + 0.2*vec3(sin(nn*112.33), 0.0, cos(nn*171.3));\n        float rr = pow(nn,3.0);\n        fpos.y += 0.08*sin(nid.x * nid.y + iTime*5.0);\n        float s2 = sphereSDF(fpos, 0.02+0.2*rr)/v;\n        rst = sdMin(rst, vec3(s2, 2.0, 0.0));\n        return vec4(rst, s2);\n    }\n\n    vec4 marching( in vec3 ro, in vec3 rd )\n    {\n        vec4 rst = vec4(0.0);\n        float t = 0.01;\n        float minDist = MAX_DISTANCE;\n        for ( int i = 0; i < MAX_STEP; ++i )\n        {\n            vec3 p = ro + t * rd;\n            vec4 dist = sceneSDF(p);\n            minDist = min(minDist, dist.w/t);\n            rst = vec4(t, dist.y, minDist, dist.w);\n            if ( abs(dist.x)< EPSILON || t>MAX_DISTANCE) break;\n            t += dist.x; \n        }\n        \n        if ( t>MAX_DISTANCE )\n        {\n            rst = vec4(MAX_DISTANCE, -1.0, minDist, MAX_DISTANCE);\n        }\n        \n        return rst;\n    }\n\n    vec3 getNormal(vec3 p) \n    {\n        return normalize(\n                vec3(\n                    sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).x - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).x,\n                    sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).x - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).x,\n                    sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).x - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).x\n                )\n            );\n    }\n\n    vec3 testSurf(vec2 p)\n    {\n        float f0 = mod(floor(p.x*2.0) + floor(p.y*2.0), 4.0);\n        float f1 = mod(floor(p.x*4.0) + floor(p.y*4.0), 2.0);\n        vec3 col = mix(vec3(0.8, 0.5, 0.4), vec3(0.5, 0.3, 0.7), f0);\n        col = mix(col, vec3(0.2, 0.4, 0.3), f1);\n        \n        return col;\n    }\n\n    vec3 shading(vec4 hit, vec3 ro, vec3 rd) \n    {\n        vec3 p = ro + hit.x * rd;\n        vec3 nor = getNormal(p);\n        \n        vec3 col = vec3(0.0);\n        vec3 surfCol = vec3(0.0);\n        vec3 coeff = vec3(0.04, 1.0, 1.0); //ambient, diffuse, specular\n        vec3 p1 = p - offset;\n        float n = texture(u_sample, p.xz*0.2).r;\n        float nf = texture(u_sample, floor(p1.xz)).r;\n        vec2 polar = vec2(atan(p1.z, p1.x), 0.5+0.1*n);\n        float detail = texture(u_sample1,  polar).r;\n        vec3 w0 = nor * nor;\n        vec3 p2 = 0.2*p1;\n        vec3 noiseTex = w0.xxx * texture(u_sample, p2.yz).rgb \n                        + w0.yyy * texture(u_sample, p2.xz).rgb\n                        + w0.zzz * texture(u_sample, p2.xy).rgb;\n        float rimPow = 8.0;\n        float t = iTime;\n        if (hit.y < 1.5)\n        {\n            float h = 0.5+0.5*sin(p.y*0.5+1.3); \n            surfCol = mix(vec3(0.1,0.58,0.85), vec3(0.0), h);\n            surfCol *= detail;\n            float tk = 0.5+0.5*(sin(length(p)+t*3.0)*cos(length(p)+t*2.0));\n            surfCol += pow(n,64.0)*vec3(0.0, 100.0,100.0)*tk;\n            surfCol *= smoothstep(-10.0, 0.0, p1.y);   \n            \n            vec3 lightDir = normalize(LIGHT_DIR); \n            vec3 viewDir = normalize(-rd);\n            vec3 reflectDir = normalize(reflect(-viewDir, nor));\n            float spec = pow(max(dot(reflectDir, viewDir), 0.0), 32.0); \n            float diff = max( dot(nor, lightDir), 0.0);\n\n            float rim = 1.0-max(dot(nor, viewDir), 0.0);\n            float rimS = pow(rim, rimPow);\n            vec3 rimCol = RIM_COLOR*rimS;\n\n            surfCol = coeff.x*surfCol + (coeff.y*surfCol*diff + coeff.z*spec)*LIGHT_COLOR;\n            surfCol += rimCol;\n        } \n        else if (hit.y < 2.5)\n        {\n            surfCol = vec3(0.01);\n        }\n        return surfCol;\n    }\n\n    vec3 render(in vec2 fragCoord) \n    {\n        vec2 uv = v_texCoord * 2.0 - 1.0;\n        uv.x *= iResolution.x/iResolution.y; \n        vec2 mo = iMouse.xy/iResolution.xy;\n        \n        vec3 ro = vec3(25.0 * cos(mo.x * 2.0 * PI), 0.0, 25.0 * sin(mo.x * 2.0 * PI));\n        vec3 ta = vec3(0.0, -5.0, 0.0);\n        mat3 cam = getCamera(ro, ta);\n        vec3 rd = normalize(cam * vec3(uv, 1.0));\n        vec4 hit = marching(ro, rd);\n        vec3 col = vec3(0.0,0.001,0.003);\n        if (hit.x < MAX_DISTANCE) \n        {\n        col = shading(hit, ro, rd);\n        }\n    \n        //glow\n        vec3 p = ro + rd * hit.x;\n        hit.z = clamp(hit.z, 0.0, 3.0);\n        float glow0 = exp(-180.0*hit.z);\n        float glow1 = min(pow(0.0013/hit.z, 32.0), 1.0);\n        vec3 glowCol = vec3(0.0);\n        \n        float v = 0.2;\n        vec3 npos = v*p;\n        vec3 nid = floor(npos+0.5);\n        float vc = hash21(nid.xz);\n        vec3 vCol = vec3(0.0,1.0,4.0)*vec3(0.0,1.0,4.0);\n        vCol.r += 3.0*vc;\n        vCol.g += 1.0*fract(vc*111.77);\n        glowCol += 0.4*vCol*glow0;  \n        glowCol += vCol*glow1; \n        float t = sin(iTime+vc*5.0);\n        float y = 3.0*t*(1.0-t); \n        glowCol *= 0.5+0.5*y;\n        col += glowCol;\n        // fog\n        col = mix( col, vec3(0.0), 1.0-exp( -0.001*hit.x*hit.x ) );\n        return col;\n        \n    }\n\n    void mainImage( out vec4 fragColor, in vec2 fragCoord )\n    {\n        vec3 col = render(fragCoord);\n        \n        col = pow(col, vec3(1.0/2.2));  \n\n        // Output to screen\n        fragColor = vec4(col,1.0);\n    }\n\n    void main() {\n        mainImage(fragColor, gl_FragCoord.xy);\n    }\n"},g={vertex:f,fragment:"#version 300 es\n    precision mediump float;\n\n    uniform sampler2D u_sample;\n    uniform vec2 u_mouse;\n    uniform float u_time;\n    uniform vec2 u_resolution;\n    \n    in vec2 v_texCoord;\n    in vec3 v_normal;\n    in vec4 v_fragPos;\n    out vec4 fragColor;\n\n    // Convert to shadertoy namings\n    #define iMouse u_mouse\n    #define iResolution u_resolution\n    #define iTime u_time\n\n    #define PI 3.1416\n    #define TERRAIN_PATTERN 4.0*sin(12.0*pos.x)+sin(20.0*pos.y)+sin(15.0*pos.z)\n    #define SPEED aTime*0.2\n    #define MAX_DIST 40.0\n    #define MAX_STEP 60\n    #define LIGHT_DIRECTION vec3(0.8,0.2,1.0)\n    #define LIGHT_INTENSITY vec3(0.5,1.0,2.0)*2.0\n    #define SKY_COLOR vec3(0.01, 0.01, 0.02)\n    #define TERRAIN_COLOR vec3(0.01,0.02,0.03)\n    #define GLOW_COLOR vec3(0.1,0.85,1.2)\n    #define RIM_POWER 0.25\n    #define AA_SIZE 1\n\n    vec3 rotateY(vec3 p, float rad) {\n        p.x = cos(rad)*p.x + sin(rad)*p.z;\n        p.z = -sin(rad)*p.x + cos(rad)*p.z;\n        return p;\n    }\n\n    vec3 rotateZ(vec3 p, float rad) {\n        p.x = cos(rad)*p.x - sin(rad)*p.y;\n        p.y = sin(rad)*p.x + cos(rad)*p.y;\n        return p;\n    }\n\n    float sdSphere(in vec3 pos, in float r)\n    {\n        return length(pos)-r;\n    }\n\n    //http://iquilezles.org/www/articles/ellipsoids/ellipsoids.htm\n    float sdElipsoid(in vec3 pos, in vec3 r)\n    {\n        float k0 = length(pos/r);\n        float k1 = length(pos/r/r);\n        return k0*(k0-1.0)/k1;\n    }\n\n    float sdRoundBox( vec3 p, vec3 b, float r )\n    {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    float sdCylinder( vec3 p, vec3 c )\n    {\n    return length(p.xz-c.xy)-c.z;\n    }\n\n    float sdCappedCylinder( vec3 p, float h, float r )\n    {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    float sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n    {\n        vec2 q = vec2( length(p.xz), p.y );\n        \n        vec2 k1 = vec2(r2,h);\n        vec2 k2 = vec2(r2-r1,2.0*h);\n        vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n        vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n        float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n        return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n    }\n\n    //http://iquilezles.org/www/articles/smin/smin.htm\n    float smin(in float a, in float b, in float k)\n    {\n        float h = max( k - abs(a-b), 0.0);\n        return min(a,b) - h*h*0.25/k;\n    }\n\n    float smax(in float a, in float b, in float k)\n    {\n        float h = max( k - abs(a-b), 0.0);\n        return max(a,b) + h*h*0.25/k;\n    }\n\n    vec4 sdUnion(vec4 d1, vec4 d2)\n    {\n        return (d1.x<d2.x)? d1:d2;\n    }\n\n    vec3 opRepLim( in vec3 p, in float s, in vec3 lim )\n    {\n        return p-s*clamp(round(p/s),-lim,lim);\n    }\n\n    vec3 opRep( vec3 p, vec3 c )\n    {\n        return mod(p,c)-0.5*c;\n    }\n\n    float tombStone(vec3 p) {\n        float b = 4.0;\n        vec3 rep = vec3(mod(abs(p.x),b)-2.5, p.y, mod(abs(p.z+1.5), b)-2.5);\n        vec2 id = vec2(floor(abs(p.x)/b),floor((p.z+1.5)/b));\n        float fid = id.x*133.3 + id.y*311.7;\n        float wr = 0.5+0.3*sin(fid);\n            \n        vec3 newP = rotateY(rep, wr);\n        newP = rotateZ(newP, 0.2*wr);\n        float d = sdRoundBox( newP, vec3(wr*0.5, wr, 0.04), 0.03);\n        return d;\n    }\n    float streetlight(vec3 p) {\n        p -= vec3(0.0,0.5,-2.0);\n        \n        //vec3 rep = opRepLim(p, 8.0, vec3(2.0, 0.0, 2.0));\n        vec3 rep = opRep(p, vec3(12.0, 0.0, 12.0));  \n        float t = iTime*0.5;\n        float d = sdCappedCone(rep, 5.0+2.0*sin(p.x*0.2+p.z*0.5+t), 0.01, 1.8 ) + 0.1*sin(p.z*3.0+p.y*2.0+iTime);\n        d *= 0.6;\n        return d;\n    }\n\n    vec4 map(in vec3 pos, float aTime)\n    {\n        vec4 res = vec4(0.0, 0.0, 0.0, 0.0);\n        float t = fract(aTime);\n        float y = 3.0*t*(1.0-t); \n        float sinT = sin(aTime);\n        vec3 cen = vec3(0.0,0.55,SPEED);\n        float sy = 0.8 + 0.2*y;\n        float sz = 1.0/sy;\n        vec3 r = vec3(0.35,0.32+0.05*sy,0.25+0.05*sz);\n        vec3 q = pos-cen;\n        vec3 h = q;\n        \n        //body \n        float ta0 = step(fract(aTime*10.0),0.99);\n        h.z -= 3.0;\n        h.z += ta0*9.0;\n        float d = sdElipsoid(h-vec3(0.0, 0.03, -0.09), r);\n        {\n        \n        //head \n        float d1 = sdElipsoid(h - vec3(0.0, 0.32, 0.01), vec3(0.28, 0.2, 0.18));\n        float d2 = sdElipsoid(h - vec3(0.0, 0.30, -0.07), vec3(0.2));\n        d2 = smin(d1, d2, 0.08);\n        d = smin(d, d2, 0.08);\n        \n        vec3 sh = vec3(abs(h.x), h.yz);//symmetric along x\n        \n        //ears\n        d2 = sdElipsoid(sh - vec3(0.15, 0.47, -0.05), vec3(0.06, 0.09, 0.04));\n        d = smin(d, d2, 0.08);\n        res = vec4(d,2.0,0.0,0.0);  \n        \n        //eyes\n        float d3 = sdSphere(sh - vec3(0.068,0.4,0.108), 0.07);\n        res = sdUnion(res, vec4(d3,3.0,0.0,0.0));\n        \n        //terrain\n        float fh = -0.05+0.05*(sin(2.5*pos.x) + sin(1.5*pos.z));\n        float d4 = pos.y - fh;\n        d4 -= .01*texture(u_sample, pos.xz).x;\n        res = sdUnion(res, vec4(d4,0.0,0.0,0.0));\n        \n        //tombstone\n        float d5 = tombStone(pos);\n        res = sdUnion(res, vec4(d5,1.0,0.0,0.0));\n        \n        //light\n        float d6 = streetlight(pos);\n        res = sdUnion(res, vec4(d6,4.0,0.0,0.0));\n        \n        float glow = d6;\n        res.w = glow;\n            \n        float shadow = min(d4, d5); \n        res.z = shadow;\n        }\n        \n        return res;\n    }\n\n    float calcOcclusion( in vec3 pos, in vec3 nor, in float aTime)\n    {\n        float occ = 0.0;\n        float sca = 1.0;\n        for( int i=0; i<4; i++ )\n        {\n            float h = 0.01 + 0.32*float(i)/4.0;\n            vec3 opos = pos + h*nor;\n            float d = map( opos, aTime ).x;\n            occ += (h-d)*sca;\n            sca *= 0.85;\n            \n        }\n        return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n    }\n\n    vec3 calcNormal(in vec3 pos, in float aTime)\n    {\n        vec2 e = vec2(0.001,0.0);\n        return normalize( vec3(map(pos + e.xyy,aTime).x - map(pos - e.xyy,aTime).x,\n                            map(pos + e.yxy,aTime).x - map(pos - e.yxy,aTime).x,\n                            map(pos + e.yyx,aTime).x - map(pos - e.yyx,aTime).x) );\n    }\n\n    float castShadow(in vec3 ro, in vec3 rd, in float aTime)\n    {\n        float res = 1.0;\n        float t = 0.01;\n        float tMax = MAX_DIST;\n        \n        for (int i=0; i<MAX_STEP;++i)\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos,aTime).z;\n            res = min( res, 16.0*h/t );\n            if (res<0.01 || t > tMax) break;\n            t += h;\n        }\n        return clamp(res, 0.0, 1.0);\n    }\n\n    vec4 castRay(in vec3 ro, in vec3 rd, in float aTime)\n    {\n    float t = 0.01;\n    vec4 m = vec4(0.0);\n    float tMax = MAX_DIST;\n    float minDist = MAX_DIST;\n    for ( int i = 0; i < MAX_STEP; ++i )\n    {\n        vec3 pos = ro + t*rd;\n        vec4 h = map( pos,aTime );\n        minDist = min(minDist, h.w/t);\n        m.x = t;\n        m.y = h.y;\n        m.z = minDist;\n        m.w = h.w;\n        \n        if ( abs(h.x)<(0.001*t) || t>tMax ) break;\n        t += h.x;\n    } \n        \n    if ( t>tMax )\n    {\n        m.x = MAX_DIST;\n        m.y = -1.0;\n        m.w = MAX_DIST;\n    }\n    \n    return m;\n    }\n\n    vec3 render(in vec2 fragCoord, in float aTime)\n    {\n        vec2 p = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n        vec2 mouse = 2.0*iMouse.xy/iResolution.xy-1.0;\n        float angle = 10.0*iMouse.x/iResolution.x;\n        \n        vec3 ta = vec3(0.0,0.85,3.0+SPEED);\n        vec3 ro = ta+vec3( 1.0*sin(angle), 0.0, 1.0*cos(angle) );;\n        \n        vec3 ww = normalize(ta - ro);\n        vec3 uu = normalize( cross( ww, vec3(0.0, 1.0, 0.0) ) );\n        vec3 vv = normalize( cross( uu, ww ) );\n        \n        \n        vec3 rd = normalize(p.x * uu + p.y * vv + 2.0*ww);\n        vec3 mDir = LIGHT_DIRECTION;\n        vec3 bg = SKY_COLOR;\n        vec3 col = bg;\n        \n        vec2 uv = rd.xz/rd.y; //sky dome( intersect the top )\n        \n        vec4 tm = castRay(ro, rd, aTime);\n        float t = tm.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, aTime);\n        vec3 mate = vec3(0.0);\n        float occ = calcOcclusion( pos, nor, aTime );\n        float fresnel = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float mDiff = clamp( dot(nor, mDir),0.0,1.0 );\n        float mShadow = castShadow(pos+nor*0.01, mDir, aTime);\n        if ( tm.x < MAX_DIST )\n        {  \n            if (tm.y == 0.0) {\n                mate = TERRAIN_COLOR;//terrain\n            } \n            else if (tm.y == 1.0){\n            mate = vec3(0.1);\n            mate += RIM_POWER*GLOW_COLOR*fresnel;    \n            }\n            else if (tm.y==2.0)\n            {\n                mate = vec3(0.5); //body\n                mDiff = 0.0;\n            } \n            else if (tm.y==3.0)\n            {\n                mate = vec3(1.0); //eyes\n                mDiff = 1.0;\n            }\n            else if (tm.y==4.0)\n            {\n                mate = vec3(0.0,0.5,0.5); //light\n                mate += step(fract(pos.y*3.0),0.25)*vec3(2.0,0.0,2.0);\n                mate += step(fract(pos.y*1.5),0.15)*vec3(0.0,2.0,2.0);\n                mDiff = 1.0;\n                mShadow = 1.0;\n                occ = 1.0;\n            }  \n        \n            col = mate*LIGHT_INTENSITY*mDiff*mShadow;\n            col *= occ*occ; \n            \n        } \n        \n        // fog\n        col = mix( col, vec3(0.0,0.05,0.05), 1.0-exp( -0.003*t*t ) );\n        \n        float glow = 0.1*exp(-64.0*tm.z); \n        col += GLOW_COLOR*glow;\n        return col;\n    }\n\n    void mainImage( out vec4 fragColor, in vec2 fragCoord )\n    {\n        vec3 col = vec3(0.0);\n        vec2 off = vec2(0.0);\n        \n    #if AA_SIZE>1\n        //anti aliasing & motion blur\n        for (float aaY = 0.0; aaY < float(AA_SIZE); ++aaY)\n        {\n            for (float aaX = 0.0; aaX < float(AA_SIZE); ++aaX)\n            {\n                off = -0.5+vec2(aaY,aaX)/float(AA_SIZE);\n                \n                float md = texelFetch(u_sample, ivec2(fragCoord)&255, 0).x;\n                float mb = (aaY*float(AA_SIZE)+aaX)/(float(AA_SIZE*AA_SIZE-1));\n                mb += (md-0.5)/float(AA_SIZE*AA_SIZE);\n                float aTime = iTime - mb*0.5*(1.0/24.0); //1 frame in 24fps for film\n    #else\n                float aTime = iTime;\n    #endif\n                col += render(fragCoord+off, aTime);\n                \n                \n    #if AA_SIZE>1\n            }\n        }\n        col /= float(AA_SIZE*AA_SIZE);\n    #endif\n        \n        //gamma\n        col = pow( col, vec3(0.4546));\n    \n        // vignetting        \n        vec2 q = v_texCoord;\n        col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n        fragColor = vec4(col, 1.0);\n    }\n\n    void main() {\n        mainImage(fragColor, gl_FragCoord.xy);\n    }\n"},x={vertex:f,fragment:"#version 300 es\n    precision mediump float;\n\n    uniform vec2 u_mouse;\n    uniform float u_time;\n    uniform vec2 u_resolution;\n    \n    in vec2 v_texCoord;\n    in vec3 v_normal;\n    in vec4 v_fragPos;\n    out vec4 fragColor;\n\n    // Convert to shadertoy namings\n    #define iMouse u_mouse\n    #define iResolution u_resolution\n    #define iTime u_time\n\n    #define PI 3.1415926\n    #define EPSILON 0.001\n    #define MAX_STEPS 100\n    #define MAX_DISTANCE 80.0\n    #define AA 1\n\n    struct Light {\n        vec3 position;\n        vec3 color;\n    };\n\n    struct Material {\n        vec3 albedo;\n        float metallic;\n        float roughness;\n        vec3 reflection;\n        vec3 refraction;\n    };\n        \n    struct Hit {\n        float dist;\n        int matIndex; //material info at the intersection point\n    };\n\n    float sdPlane( vec3 p, vec4 n )\n    {\n    // n must be normalized\n    return dot(p, n.xyz) + n.w;\n    }\n\n    float sdBox( vec3 p, vec3 b )\n    {\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0))\n            + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n    }\n\n\n    float sphereSDF(vec3 p, float r) {\n        return length(p) - r;\n    }\n\n    Hit unionSDF(Hit d1, Hit d2) \n    {\n        if (d1.dist < d2.dist) {\n            return d1;\n        } else {\n            return d2;\n        }  \n    }\n\n    vec3 doTranslate(vec3 p, vec3 offset) \n    {\n        return p - offset;\n    }\n\n    Hit sceneSDF(vec3 p) {\n        Hit rst;\n        \n        vec3 p1 = doTranslate(p, vec3(10.0*cos(iTime), 1.0, 10.0*sin(iTime)));\n        Hit is0 = Hit(sphereSDF(p1, 1.0), 1);\n        p1 = doTranslate(p, vec3(1.0, 1.5, -2.0));\n        Hit is1 = Hit(sphereSDF(p1, 1.5 ), 2);\n        \n        /*\n        Hit is2 = Hit(sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0)), 3);\n        Hit is3 = Hit(sdPlane( p, vec4(0.0, 0.0, 1.0, 20.0)), 3);\n        Hit is4 = Hit(sdPlane( p, vec4(1.0, 0.0, 0.0, 20.0)), 3);\n        Hit is5 = Hit(sdPlane( p, vec4(-1.0, 0.0, 0.0, 20.0)), 3);\n        Hit is6 = Hit(sdPlane( p, vec4(0.0, 0.0, -1.0, 20.0)), 3);\n        Hit is7 = Hit(sdPlane( p, vec4(0.0, -1.0, 0.0, 30.0)), 3);\n        */\n        \n        Hit outerBox = Hit(sdBox(p-vec3(0.0,25.0,0.0), vec3(25.0,25.0,25.0)), 3); \n        outerBox.dist = -outerBox.dist-0.1;\n        \n        rst = unionSDF(is0, is1);\n        rst = unionSDF(rst, outerBox);\n        \n        /*\n        rst = unionSDF(rst, is2);\n        rst = unionSDF(rst, is3);\n        rst = unionSDF(rst, is4);\n        rst = unionSDF(rst, is5);\n        rst = unionSDF(rst, is6);\n        rst = unionSDF(rst, is7);\n        */\n        return rst;\n    }\n\n    vec3 getNormal(vec3 p) {\n        return normalize(vec3(\n            sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).dist - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).dist,\n            sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).dist - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).dist,\n            sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).dist - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).dist\n        ));\n    }\n\n    Hit marching(vec3 ro, vec3 rd) \n    {\n        float tmax = MAX_DISTANCE;\n        float t = 0.001;\n        Hit result = Hit(-1.0, -1);\n        \n        for (int i = 0; i < MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * t;\n            Hit res = sceneSDF(p);\n            if (res.dist < EPSILON)\n            {\n                return result;\n            }\n            else if (t > tmax)\n            {\n                result.matIndex = -1;\n                result.dist = tmax;\n                break;\n            }\n            t += res.dist;\n            result.dist = t;\n            result.matIndex = res.matIndex;\n        }\n        \n        return result;\n    }\n\n    float calcShadow(in vec3 ro, in vec3 rd) {\n        float mint = 0.1;\n        float t = mint;\n        float res = 1.0;\n        float k = 4.0;\n        for (int i = 0; i < 40; i++)\n        {\n            float h = sceneSDF(ro + rd * t).dist;\n            \n            res = min( res, k * h / t );\n            t += clamp( h, 0.02, 0.20 );\n        \n            if ( h < EPSILON ) \n            {\n                res = min(res, 0.0);\n                break;\n            } \n        }\n        return clamp( res, 0.0, 1.0 );\n    }\n\n\n    float calcAO( in vec3 pos, in vec3 nor )\n    {\n        float occ = 0.0;\n        float sca = 1.0;\n        float h = 0.001;\n        for( float i = 0.0; i < 5.0; i++ )\n        {\n            float d = sceneSDF( pos + h * nor ).dist;\n            occ += ( h - d ) * sca;\n            sca *= 0.85;\n            h += 0.45 * i / 5.0;\n        }\n        return clamp( 1.0 - occ, 0.0, 1.0 );    \n    }\n\n    //Fresnel/reflectivity\n    vec3 Fs(vec3 h, vec3 v, vec3 f0)\n    {\n        float dothv = max(dot(h, v), 0.0);\n        return max(f0 + (1.0 - f0) * pow((1.0 - dothv), 5.0), 0.0);\n    }\n\n    //Distribution/concentration\n    float D_GGX(float dotnh, float roughness) \n    {\n        float a = roughness * roughness;\n        float a2 = a * a;\n        float dotnh2 = dotnh * dotnh;\n        float denom =  max(dotnh2 * (a2 - 1.0) + 1.0, EPSILON);\n        return a2 /(PI * denom * denom);\n    }\n\n    float G_SGGX(float dotnv, float roughness)\n    {\n        float r = roughness + 1.0; \n        float k = (r * r) / 8.0;\n        return dotnv / (dotnv * (1.0 - k) + k);\n    }\n\n    //Geometry/shadowing masking\n    float G_Smith(float dotnv, float dotnl, float roughness)\n    {\n        \n        float ggx1 = G_SGGX(dotnv, roughness);\n        float ggx2 = G_SGGX(dotnl, roughness);\n        return ggx1 * ggx2;\n    }\n\n    //Fresnel/reflectivity\n    vec3 Fs(float dothv, vec3 f0)\n    {\n        vec3 F = f0 + (1.0 - f0) * pow((1.0 - dothv), 5.0);\n        return max(F, 0.0);\n    }\n\n    vec3 shading(vec3 ro, vec3 p, vec3 normal, Light lightInfo, inout Material mat) \n    {\n        vec3 Lo = vec3(0.0);\n        \n        //material and light\n        vec3 albedo = mat.albedo; //vec3(0.2, 0.87, 0.6);\n        float roughness = mat.roughness;\n        float metallic = mat.metallic;\n        vec3 lightDir = lightInfo.position - p;\n        vec3 lightColor = lightInfo.color; \n        \n        //calculating vectors\n        vec3 viewDir = ro - p;\n        vec3 V = normalize(viewDir);\n        vec3 N = normal;\n        vec3 L = normalize(lightDir);\n        vec3 H = normalize(V + L);\n        \n        float dist = length(lightDir);\n\n        float sd = calcShadow(p, L);\n        float att = 1.0 / ( dist);\n        vec3 radiance = lightColor * att * sd;\n\n        float dothv = max(dot(H, V), 0.0);\n        float dotnh = max(dot(N, H), 0.0);\n        float dotnv = max(dot(N, V), 0.0);\n        float dotnl = max(dot(N, L), 0.0);\n        \n        //fresnel\n        vec3 f0 = vec3(0.04); \n        f0 = mix(f0, albedo, metallic);\n        vec3 F = Fs(dothv, f0);\n        \n        //cook-torrance specualr term\n        float D = D_GGX(dotnh, roughness);\n        float GS = G_Smith(dotnv, dotnl, roughness);\n        vec3 nom = D * GS * F;\n        float denom = 4.0 * dotnv * dotnl;\n        vec3 Fct = nom / max(denom, EPSILON); //avoid zero denom\n\n        vec3 Ks = F; //reflect\n        vec3 Kd = 1.0 - Ks; \n        Kd *= 1.0 - metallic; //diffuse\n        vec3 Fl = albedo/PI; //lambert\n        \n        mat.reflection = Ks;\n        \n        Lo += (Kd * Fl + Fct) * radiance * dotnl; \n        \n        float ao = calcAO(p, N);\n        vec3 ambient = vec3(0.01) * albedo * ao;\n        return ambient + Lo;\n    }\n\n    mat3 getCamera( in vec3 ro, in vec3 ta) {\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(0.0, 1.0, 0.0);\n        vec3 cu = normalize( cross(cw,cp) );\n        vec3 cv =          ( cross(cu,cw) );\n        return mat3( cu, cv, cw );\n    }\n\n    //hacks for non-constant index expression\n    Material getMaterial(int index) {\n        Material mat[4];\n        mat[0] = Material(vec3(1.0), 0.5, 0.1, vec3(0.0), vec3(0.0)); //white\n        mat[1] = Material(vec3(0.5, 0.8, 0.5), 0.9, 0.2, vec3(0.0), vec3(0.0)); //green\n        mat[2] = Material(vec3(0.9, 0.9, 0.2), 0.9, 0.2, vec3(0.0), vec3(0.0)); //yellow\n        mat[3] = Material(vec3(0.8, 0.5, 0.5), 0.5, 0.3, vec3(0.0), vec3(0.0)); //pink\n        if (index == 0) {\n            return mat[0];\n        } else if (index == 1) {\n            return mat[1];\n        } else if (index == 2) {\n            return mat[2];\n        } else if (index == 3) {\n            return mat[3];\n        }\n    }\n\n    vec3 render(in vec2 fragCoord)\n    {\n        vec2 uv = v_texCoord;\n        uv.x *= iResolution.x/iResolution.y; \n        uv = 2.0 * uv - 1.0; \n        vec3 col = vec3(0.0);\n        vec2 mouse = vec2(0.01) + iMouse.xy/iResolution.xy;\n        \n        vec3 ro = vec3(10.0 * cos(mouse.x * 2.0 * PI), 6.0 + 5.0 * mouse.y, 10.0 * sin(mouse.x * 2.0 * PI));\n        vec3 ta = vec3(0.0, 4.0, 0.0);\n        mat3 cam = getCamera(ro, ta);\n        vec3 rd = normalize(cam * vec3(uv, 1.0));\n        \n        Light lightInfo = Light(vec3(5.0 * sin(iTime), 10.0, 2.0), vec3(200.0));\n        \n        Hit icp;\n        vec3 nor = vec3(0.0);  \n        vec3 ori = ro;\n        vec3 dir = rd;\n        vec3 interP = vec3(0.0);\n        vec3 mask = vec3(1.0);\n        float travelDist = 0.0; //calculate how far a ray travels\n        \n        for (float i = 0.0; i < 3.0; i++) {\n            icp = marching(ori, dir);\n            interP = ori + (icp.dist) * dir; //interception point\n            travelDist += length(ori - interP);\n            nor = getNormal(interP);\n            if (icp.dist >= MAX_DISTANCE) {\n                col += vec3(0.0);\n            } else {\n                Material mat = getMaterial(icp.matIndex);\n                col += mask * shading(ori, interP, nor, lightInfo, mat);\n                \n                vec3 ref = reflect(dir, nor);\n                ori = interP + EPSILON*ref;\n                dir = ref;\n                mask *= mat.reflection * 0.8;\n            }\n        }\n        return col;\n    }\n\n    void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n        \n        vec3 col = vec3(0.0);\n        vec2 offset = vec2(0.0);\n    #if AA>1\n        for (int y = 0; y < AA; ++y)\n        {\n            for (int x = 0; x < AA; ++x)\n            {\n                offset = -0.5+vec2(float(x), float(y))/float(AA);\n\n                col += render(fragCoord+offset);\n            }\n        }\n        col /= float(AA*AA);\n    #else\n        col += render(fragCoord);\n    #endif\n        \n        //col = col/(col + vec3(1.0)); //Reinhard tone mapping\n        col = vec3(1.0) - exp(-col * 0.5);//exposure\n        col = pow(col, vec3(1.0/2.2)); \n        fragColor = vec4(col,1.0);\n    }\n\n    void main() {\n        mainImage(fragColor, gl_FragCoord.xy);\n    }\n"},y={vertex:f,fragment:"#version 300 es\n    precision mediump float;\n\n    uniform vec2 u_mouse;\n    uniform float u_time;\n    uniform vec2 u_resolution;\n    uniform sampler2D u_sample;\n    uniform sampler2D u_sample1;\n    \n    in vec2 v_texCoord;\n    in vec3 v_normal;\n    in vec4 v_fragPos;\n    out vec4 fragColor;\n\n    // Convert to shadertoy namings\n    #define iMouse u_mouse\n    #define iResolution u_resolution\n    #define iTime u_time\n\n    #define EPSILON 0.0001\n    #define SUN_COLOR vec3(1.2, 1.1, 0.8) \n    #define SUN_POS vec3(500.0, 160.0, 400.0)\n    #define SUN_DIR vec3(0.0,0.8,0.0)\n    #define SUN_GLOW vec3(1.2,0.6,0.3)\n    #define SKY_COLOR vec3(0.5,0.7,1.0)\n    #define OCEAN_COLOR vec3(0.04, 0.2, 0.6)\n    #define CLOUD_COLOR vec3(1.0)\n    #define MAX_STEP 60\n    #define MAX_DIST 30.0\n    #define AA 1\n\n    float noise(in vec2 uv) {\n        return texture(u_sample, uv/64.0).r;\n    }\n\n    float smoothNoise(in vec2 uv) {\n        vec2 luv = fract(uv); //range from 0.0 to 1.0\n        vec2 id = floor(uv); //the integer part of uv, 0, 1, 2\n        luv = luv*luv*(3.0 - 2.0*luv); //similar to smoothstep\n        \n        //get values from the cordinates of a square\n        float bl = noise(id);\n        float br = noise(id + vec2(1.0, 0.0));\n        float tl = noise(id + vec2(0.0, 1.0));\n        float tr = noise(id + vec2(1.0, 1.0));\n        \n        float b = mix(bl, br, luv.x); //interpolate between bl and br\n        float t = mix(tl, tr, luv.x); //interpolate between tl and tr\n        \n        return mix(b, t, luv.y);\n    }\n\n    float fbm4(in vec2 uv) {\n        float amp = 0.5;\n        float f = 2.0;\n        float h = 0.0;\n        float a = 0.0;\n        for (int i = 0; i < 4; i++){\n            h += amp * smoothNoise(uv*f);\n            a += amp;\n            amp *= 0.5;\n            f *= 2.0;\n        }\n        \n        h /= a;\n        return h;\n    }\n\n    float smoothUnion( float d1, float d2, float k ) \n    {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); \n    }\n\n    float displacement (vec3 p) \n    {\n        return sin(-p.y*0.8);\n    }\n\n    float sphereSDF(vec3 p, float r) {\n        return length(p) - r;\n    }\n\n    const vec3 SCALE = vec3(18.0, 12.0, 15.0);\n    vec4 stuff(vec3 p) {\n        float t = sin(iTime*0.5 + p.x * 0.22 + p.z * 0.13 + p.y * 0.15);\n        p = p - vec3(6.0, 0.8+t*t, 6.0);\n        //vec3 q = p - SCALE * clamp(round(p/SCALE), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n        //vec2 id = vec2(floor(q.x/5.0 - 2.5),floor(q.z/5.0 - 2.5));\n        //float fid = id.x*13.3 + id.y*5.7;\n        //float wr = 1.2+0.5*sin(fid);\n        \n        float wr = 1.2;\n        float d = sphereSDF(p, wr) + displacement(p);\n        d *= 0.5;\n        return vec4(d, 3.0, 0.0, 1.0);\n    }\n\n    vec4 sdUnion(vec4 d1, vec4 d2)\n    {\n        return (d1.x<d2.x)? d1:d2;\n    }\n\n    float wave(in vec3 p) \n    {\n        float t = iTime * 0.5;\n        float hi = 0.0;\n        hi += 0.15*smoothNoise(vec2(p.x*3.0 + t, p.z*2.5 + t));\n        hi += 0.13*smoothNoise(vec2(p.x*2.2 - 1.5*t, 0.0));\n        hi += 0.11*smoothNoise(vec2(p.x*2.2 - t, p.z*3.2 - t));\n        return hi;\n    }\n\n    vec4 water(in vec3 p, float h) {\n        \n        float hi = wave(p);\n        h += 0.15*hi;\n        float d = p.y - h;\n        return vec4(d, 1.0, 1.0, 0.0);\n    }\n\n    vec2 rot2D(in vec2 xy, float d)\n    {\n        float c = cos(d);\n        float s = sin(d);\n        return vec2(xy.x * c - xy.y * s, xy.x * s + xy.y * c);\n    }\n\n    vec4 land(in vec3 p, float h) {\n        float hi = 0.0;\n        float wave = 0.8*sin(-p.x*0.1) + 0.8*sin(-p.z*0.17);\n        \n        vec2 xy = rot2D(p.xz, -0.8); \n        //hi += 0.005*smoothNoise(vec2(xy.x*17.37, xy.y*5.5)); //a bit of a sand pattern\n        \n        h += wave ;\n        h += hi;\n        h -= 0.008*texture(u_sample1, p.xz*0.7).r; \n        float d = p.y - h;\n        return vec4(d, 2.0, 0.0, 0.0);\n    }\n\n    vec4 map(in vec3 p) {\n        vec4 res = vec4(0.0); //distance, material, reflect, refract\n        //p.z -= 1.5;\n        vec4 d0 = land(p, -0.5);\n        vec4 d1 = stuff(p);\n        vec4 d2 = water(p, -0.4);\n        res = sdUnion(d0, d1);\n        res = sdUnion(res, d2); \n        \n        return res;\n    }\n\n    float castRayB(in vec3 ro, in vec3 rd) {\n    float t = 0.01;\n    for ( int i = 0; i < 30; ++i )\n    {\n        vec3 pos = ro + t * rd;\n        vec4 h = stuff( pos );\n        if ( h.x < EPSILON) return t;\n        t += h.x;\n        if (t > MAX_DIST) return MAX_DIST;\n    } \n    return MAX_DIST;\n    }\n\n    vec4 castRay(in vec3 ro, in vec3 rd)\n    {\n    float t = 0.01;\n    vec3 m = vec3(0.0);\n    float tMax = MAX_DIST;\n\n    for ( int i = 0; i < MAX_STEP; ++i )\n    {\n        vec3 pos = ro + t * rd;\n        vec4 h = map( pos );\n        m = h.yzw;\n        if ( h.x < EPSILON * t ||  t > tMax)\n        {\n            break;\n        }\n        t += h.x;\n    } \n        \n    if ( t>tMax )\n    {\n        m = vec3(-1.0);\n    }\n    return vec4(t,m);\n    }\n\n    vec3 getNormal(vec3 p) {\n        return normalize(vec3(\n            map(vec3(p.x + EPSILON, p.y, p.z)).x - map(vec3(p.x - EPSILON, p.y, p.z)).x,\n            map(vec3(p.x, p.y + EPSILON, p.z)).x - map(vec3(p.x, p.y - EPSILON, p.z)).x,\n            map(vec3(p.x, p.y, p.z + EPSILON)).x - map(vec3(p.x, p.y, p.z - EPSILON)).x\n        ));\n    }\n\n\n    vec3 sky2D(vec3 skyColor, vec3 cloudColor, vec2 uv) {\n        vec3 col = vec3(0.0);\n        float t = iTime * 0.1;\n        float n1 = fbm4(vec2(uv.x + t, uv.y - t));\n        col = mix( skyColor, cloudColor, smoothstep(0.2, 0.8, n1));\n        return col;\n    }\n\n    float calcOcclusion( in vec3 pos, in vec3 nor)\n    {\n        float occ = 0.0;\n        float sca = 1.0;\n        for( int i=0; i<4; i++ )\n        {\n            float h = 0.01 + 0.16*float(i)/4.0;\n            vec3 opos = pos + h*nor;\n            float d = map( opos ).x;\n            occ += (h-d)*sca;\n            sca *= 0.8;\n        }\n        return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n    }\n\n    vec3 calcSky(vec3 ro, vec3 rd) {\n        //from IQ.\n        const float SC = 1e5;\n        //Trace out to a distant XZ plane.\n        float dist = (SC - ro.y)/rd.y; \n        vec2 p = (ro + dist*rd).xz;\n        \n        vec3 sunDir = normalize(SUN_POS - ro);\n        float sun = max(dot(sunDir, rd), 0.0);\n        float core = smoothstep(0.98, 1.0, sun);\n        \n        vec3 skyCol = vec3(0.0);\n        vec3 cloudCol = CLOUD_COLOR;\n        \n        \n        skyCol += 0.5*SUN_COLOR*pow(core, 64.0);\n        skyCol += 0.8*SUN_GLOW*pow(sun, 32.0);\n        skyCol += mix(SUN_GLOW, SKY_COLOR, 2.0*abs(rd.y));//horizontal brightness\n        \n        skyCol = sky2D(skyCol, cloudCol, p*1.2/SC);\n        float grad = smoothstep(0.0, 0.1, rd.y);\n        skyCol = mix(SUN_GLOW, skyCol, grad);\n        return skyCol;\n    }\n\n    vec3 calcLighting(in vec3 ro, in vec3 rd, in vec4 hit) {\n        vec3 outCol = vec3(0.0);\n        vec3 hitPoint = ro + hit.x * rd;\n        vec3 sunDir = normalize(SUN_POS - ro);\n        vec3 nor = getNormal(hitPoint);\n        \n        // draw water color \n        vec3 waterCol = vec3(0.0);\n        \n        // water reflection\n        vec3 refDir = normalize(reflect(rd, nor));\n        vec3 reflectCol = calcSky(hitPoint, refDir);\n        \n        // water specular\n        vec3 H = normalize(sunDir - rd);\n        float RN = max(dot(H, nor), 0.0);\n        float spec = 0.8*pow(RN, 32.0);\n        vec3 specCol = (SUN_COLOR + SUN_GLOW) * spec; \n        \n        // water flare \n        float rnd = 2.0*noise(vec2(hitPoint.x * 3.4738, hitPoint.z * 7.7319));\n        rnd *= 1.0-exp(-0.2*hit.x);\n        specCol +=  rnd * spec;\n        \n        // water diffuse \n        float diff = max(dot(sunDir, nor), 0.0); \n        vec3 diffCol = SUN_COLOR  * OCEAN_COLOR;\n        \n        // fresnel\n        float fresnel = 1.0 - max(dot(nor,-rd),0.0);\n        fresnel = pow(fresnel,3.0);\n        waterCol = mix(diffCol, specCol + reflectCol, fresnel); \n        \n        // land\n        vec3 landDiff = SUN_GLOW * diff;\n        \n        //refract \n        float refractRatio = 0.75;\n        vec3 refractDir = normalize(refract(rd, nor, refractRatio));\n        vec3 refractCol = calcSky(hitPoint, refractDir);\n        \n        //reflect\n        float t = castRayB(hitPoint, refDir);\n        if (t < MAX_DIST) {\n            waterCol *= vec3(1.0, 0.92, 0.92); //fake reflection\n        }\n        \n        \n        if (hit.y == 1.0) {\n            outCol = waterCol;\n        } else {\n            // wet area\n            float w0 = smoothstep(-0.3, -0.15-0.1*rnd, hitPoint.y);\n            outCol = mix(landDiff*0.5, landDiff, w0);\n\n            float w1 = smoothstep(-0.4, -0.2, hitPoint.y);\n            outCol = mix(waterCol, outCol, w1);\n        }  \n        \n        outCol = mix(outCol, refractCol , hit.w);\n        return outCol;\n    }\n\n    mat3 getCamera( in vec3 ro, in vec3 ta, float cr )\n    {\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n        vec3 cu = normalize( cross(cw,cp) );\n        vec3 cv =          ( cross(cu,cw) );\n        return mat3( cu, cv, cw );\n    }\n\n    vec3 render(in vec2 fragCoord) {\n        vec2 uv = fragCoord.xy/iResolution.xy;\n        uv -= 0.5; // translate to the center of the screen\n        uv.x *= iResolution.x / iResolution.y; // restore aspect ratio\n        vec2 mouse = iMouse.xy/iResolution.xy;\n        mouse.y -= 0.5;\n        \n        //define camera\n        float t = iTime * 0.1;\n        vec3 ro = vec3(0.0, 0.0, 0.0);\n        vec3 ta = vec3(cos(mouse.x * 6.28 + t), mouse.y*3.0, sin(mouse.x * 6.28 + t));\n        mat3 cam = getCamera(ro, ta, 0.0);\n        vec3 rd = normalize(cam * vec3(uv, 1.0));\n        rd = normalize(rd);\n        vec3 bgCol = calcSky(ro, rd);\n        vec3 outCol = vec3(0.0);\n        outCol = bgCol;\n        \n        vec4 hit = castRay(ro, rd);\n        vec3 pos = ro + hit.x * rd;\n        vec3 nor = getNormal(pos);\n        \n        if (hit.x < MAX_DIST) {\n            outCol = calcLighting(ro, rd, hit);\n            // fog\n            outCol = mix( outCol, SUN_GLOW, 1.0 - exp( -0.008 * hit.x * hit.x ) );\n        }\n        return outCol;\n    }\n\n    void mainImage( out vec4 fragColor, in vec2 fragCoord )\n    {\n        vec3 pixCol = vec3(0.0);\n        vec2 offset = vec2(0.0);\n        \n    #if AA>1\n        for (float y = 0.0; y < float(AA); ++y)\n        {\n            for (float x = 0.0; x < float(AA); ++x)\n            {\n                offset = -0.5 + vec2(x, y) / float(AA);\n\n                pixCol += render(fragCoord+offset);\n            }\n        }\n        pixCol /= float(AA*AA);\n    #else\n        pixCol += render(fragCoord);\n    #endif\n        \n        // tone mapping\n        //float exposure = 1.0;\n        //pixCol = 1.0 - exp(-pixCol * exposure);\n        \n        // gamma\n        pixCol = pow( pixCol, vec3(0.4546));\n        \n        // vignetting        \n        vec2 q = v_texCoord;\n        pixCol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.3);\n        fragColor = vec4(pixCol, 1.0);\n        \n    }\n\n    void main() {\n        mainImage(fragColor, gl_FragCoord.xy);\n    }\n"},b={vertex:f,fragment:"#version 300 es\n    precision mediump float;\n\n    uniform vec2 u_mouse;\n    uniform float u_time;\n    uniform vec2 u_resolution;\n    uniform sampler2D u_sample;\n    \n    in vec2 v_texCoord;\n    in vec3 v_normal;\n    in vec4 v_fragPos;\n    out vec4 fragColor;\n\n    // Convert to shadertoy namings\n    #define iMouse u_mouse\n    #define iResolution u_resolution\n    #define iTime u_time\n\n    #define PI 3.1416\n    #define MAX_STEP 80\n    #define EPSILON 0.01\n    #define SUN_DIR vec3(-1.0,0.0,-2.0)\n    #define SUN_COLOR vec3(0.7,0.4,0.3)\n    #define SUN_GLOW vec3(0.7,0.5,0.5)\n    #define SKY_COLOR vec3(0.7,0.8,0.9)\n    #define CLOUD_SHADOW vec3(0.5,0.2,0.2)\n    #define CLOUD_COLOR vec3(1.0)\n\n    float hash1(in vec2 uv) {\n        return 2.0*texture(u_sample, uv/64.0).r - 1.0;\n    }\n\n    float smoothNoise(in vec3 p) {\n        vec2 luv = fract(p.xz); //range from 0.0 to 1.0\n        vec2 id = floor(p.xz); //the integer part of uv, 0, 1, 2\n        luv = luv*luv*(3.0 - 2.0*luv); //similar to smoothstep\n        \n        //get values from the cordinates of a square\n        float bl = hash1(id);\n        float br = hash1(id + vec2(1.0, 0.0));\n        float tl = hash1(id + vec2(0.0, 1.0));\n        float tr = hash1(id + vec2(1.0, 1.0));\n        \n        float b = mix(bl, br, luv.x); //interpolate between bl and br\n        float t = mix(tl, tr, luv.x); //interpolate between tl and tr\n        \n        return mix(b, t, luv.y);\n    }\n\n    vec3 rotZ(in float rad, in vec3 pos)\n    {\n        mat2 rot = mat2(cos(rad), -sin(rad), sin(rad), cos(rad));\n        pos.xy = rot*pos.xy;\n        return pos;\n    }\n\n    vec3 path(in vec3 pos)\n    {\n        float a = sin(iTime*0.2)*0.12*PI;\n        pos = rotZ(a, pos);\n        return pos;\n    }\n\n    mat3 getCamera( in vec3 ta, in vec3 ro )\n    {\n        vec3 ww = normalize(ta-ro);\n        vec3 up = vec3(0.0,1.0,0.0);\n        up = path(up);\n        vec3 uu = normalize(cross(ww, up));\n        vec3 vv = normalize(cross(uu,ww));\n        return mat3(uu,vv,ww);\n    }\n\n    mat2 m2 = mat2(0.8, 0.6, -0.6, 0.8);\n    float map4(in vec3 p)\n    {\n        float scale = 0.8;\n        p *= scale;\n        vec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n        float f = 0.0;\n        float amp = 0.5;\n        for (int i = 0; i < 4; i++)\n        {\n            f += amp*smoothNoise( q );\n            q.xz = m2*q.xz;\n            q *= 2.02;\n            amp *= 0.5;\n        }\n        return 2.2 * f;\n    }\n\n    float cloudIntersect(in vec3 p) {\n        float f = map4(p);\n        return f - p.y;\n    }\n\n    vec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol )\n    {\n        vec4 sum = vec4(0.0);\n        float t = 0.0;\n        \n        /*from iq's clouds: https://www.shadertoy.com/view/XslGRr*/\n        for(int i=0; i<MAX_STEP; i++) \n        { \n            vec3  pos = ro + t*rd; \n            float den = cloudIntersect( pos ); \n            \n            //early quit for better performance, some treaks on pos.y range\n            if ( pos.y < -2.0 || pos.y > 3.5 || sum.a > 0.99) break; \n            \n            if (den > EPSILON)\n            {\n                //base color\n                vec4 col = vec4( mix( CLOUD_COLOR, CLOUD_SHADOW, den ), den );\n                \n                //brighter towards the sun\n                float dif =  clamp((den - cloudIntersect(pos+0.5*normalize(SUN_DIR))), 0.0, 1.0 ); \n                vec3 lin = SUN_COLOR*dif;   \n                col.xyz += lin;\n                \n                //mix with background according to distance\n                col.xyz = mix( bgcol, col.xyz, exp(-0.01*t*t) );\n                \n                // front to back blending    \n                col.a *= 0.5;\n                col.rgb *= col.a;\n                sum += col*(1.0-sum.a); \n            }\n            t += max(0.08,0.03*t); \n        } \n        return sum;\n    }\n\n    vec3 render( in vec2 fragCoord )\n    {\n        vec3 col = vec3(0.0);\n        vec2 uv = v_texCoord;\n        uv.x *= iResolution.x/iResolution.y;\n        uv = 2.0 * uv - 1.0;\n        \n        vec2 mouse = iMouse.xy/iResolution.xy;\n        \n        //vec3 ro = vec3(2.0*sin(mouse.x*6.28),mouse.y+0.1,2.0*cos(mouse.x*6.28));\n        //vec3 ta = vec3(0.0,0.2,0.0);\n        \n        vec3 ro = vec3(0.0, 0.4, 0.0);\n        vec3 ta = ro + vec3(0.0, -0.1, -1.0);\n        \n        mat3 cam = getCamera(ta,ro);\n        vec3 rd = normalize(cam*(vec3(uv,1.0)));\n        \n        vec3 sunDir = normalize(SUN_DIR);\n        float sun = max(dot(sunDir, rd),0.0);\n        vec3 skyCol = vec3(0.0);\n        \n        skyCol += mix(SUN_GLOW, SKY_COLOR, 2.0*abs(rd.y));//horizontal brightness\n        skyCol += 0.3*SUN_COLOR*pow(sun, 64.0);\n        skyCol += 0.5*SUN_GLOW*pow(sun, 16.0);\n        \n        vec4 cloudCol = raymarch(ro, rd, skyCol);\n        col = skyCol*(1.0-cloudCol.a) + cloudCol.xyz; \n        \n        col += 0.7*SUN_GLOW*pow(sun, 8.0); //adding extra sun glow\n        return col;\n    }\n\n    void mainImage( out vec4 fragColor, in vec2 fragCoord )\n    {\n        vec3 col = render(fragCoord);\n        col = pow( col, vec3(1.0/2.2));\n        // vignetting        \n        vec2 q = v_texCoord;\n        col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.65);\n        \n        fragColor = vec4(col,1.0);\n    }\n\n    void main() {\n        mainImage(fragColor, gl_FragCoord.xy);\n    }\n"},C={vertex:f,fragment:"#version 300 es\n    precision mediump float;\n\n    uniform vec2 u_mouse;\n    uniform float u_time;\n    uniform vec2 u_resolution;\n    \n    in vec2 v_texCoord;\n    in vec3 v_normal;\n    in vec4 v_fragPos;\n    out vec4 fragColor;\n\n    // Convert to shadertoy namings\n    #define iMouse u_mouse\n    #define iResolution u_resolution\n    #define iTime u_time\n\n    #define PI 3.1415926\n    #define EPSILON 0.001\n    const int MAX_STEPS = 60;\n    const float MAX_DISTANCE = 80.0;\n\n    struct Ray {\n        vec3 ro;\n        vec3 rd;\n    };\n\n    struct Light {\n        vec3 position;\n        vec3 color;\n    };\n        \n    Light lightInfo = Light(vec3(3.0, 10.0, 0.0), vec3(10.0));\n\n    struct Material {\n        vec3 albedo;\n        float diffuse;\n        float specular;\n        float reflection;\n        float refraction;\n    };\n        \n    struct Hit {\n        float dist;\n        int matIndex; //material info at the intersection point\n    };\n\n    float planeSDF(vec3 p) {\n        return p.y;\n    }\n\n    float sdPlane( vec3 p, vec4 n )\n    {\n    // n must be normalized\n    return dot(p, n.xyz) + n.w;\n    }\n\n    float sphereSDF(vec3 p, float r) {\n        return length(p) - r;\n    }\n\n    float sdBox( vec3 p, vec3 b )\n    {\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0))\n            + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n    }\n\n    Hit unionSDF(Hit d1, Hit d2) \n    {\n        if (d1.dist < d2.dist) {\n            return d1;\n        } else {\n            return d2;\n        }  \n    }\n\n    vec3 doTranslate(vec3 p, vec3 offset) \n    {\n        return p - offset;\n    }\n\n    vec3 rotX(vec3 p, float d) \n    {\n        mat4 rotM= mat4(1.0, 0.0, 0.0, 0.0, \n                        0.0, cos(d), -sin(d), 0.0, \n                        0.0, sin(d), cos(d), 0.0, \n                        0.0, 0.0, 0.0, 1.0);\n        return vec3(rotM * vec4(p, 1.0));\n    }\n\n    Hit sceneSDF(vec3 p) {\n        Hit rst;\n        vec3 p1 = doTranslate(p, vec3(6.0, 3.1, -3.0));\n        Hit is0 = Hit(sphereSDF(p1, 3.0), 2);\n        p1 = doTranslate(p, vec3(-2.0, 2.1, 8.0));\n        Hit is1 = Hit(sphereSDF(p1, 2.0 ), 2);\n        p1 = doTranslate(p, vec3(3.0, 1.5 + 10.0 * abs(sin(2.0*iTime)), 1.0));\n        Hit is2 = Hit(sphereSDF(p1, 1.5 ), 1);\n        \n        /*\n        Hit is3 = Hit(sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0)), 0);\n        Hit is4 = Hit(sdPlane( p, vec4(0.0, 0.0, 1.0, 20.0)), 0);\n        Hit is5 = Hit(sdPlane( p, vec4(1.0, 0.0, 0.0, 20.0)), 0);\n        Hit is6 = Hit(sdPlane( p, vec4(-1.0, 0.0, 0.0, 20.0)), 0);\n        Hit is7 = Hit(sdPlane( p, vec4(0.0, 0.0, -1.0, 20.0)), 0);\n        Hit is8 = Hit(sdPlane( p, vec4(0.0, -1.0, 0.0, 30.0)), 0);\n        */\n        \n        Hit outerBox = Hit(sdBox(p-vec3(0.0,25.0,0.0), vec3(25.0,25.0,25.0)), 0); \n        outerBox.dist = -outerBox.dist;\n        \n        p1 = doTranslate(p, vec3(0.0, 3.5, -1.0));\n        Hit is9 = Hit(sdBox( p1, vec3(1.0, 3.0, 4.0)), 3);\n        \n        rst = unionSDF(is0, is1);\n        rst = unionSDF(rst, is2);\n        rst = unionSDF(rst, outerBox);\n        /*\n        rst = unionSDF(rst, is3);\n        rst = unionSDF(rst, is4);\n        rst = unionSDF(rst, is5);\n        rst = unionSDF(rst, is6);\n        rst = unionSDF(rst, is7);\n        rst = unionSDF(rst, is8);\n        */\n        rst = unionSDF(rst, is9);\n        return rst;\n    }\n\n    vec3 getNormal(vec3 p) {\n        return normalize(vec3(\n            sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).dist - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).dist,\n            sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).dist - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).dist,\n            sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).dist - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).dist\n        ));\n    }\n\n    Hit marching(vec3 ro, vec3 rd, float signInd) \n    {\n        float tmax = MAX_DISTANCE;\n        float t = EPSILON;\n        Hit result = Hit(-1.0, -1);\n        \n        for (int i = 0; i < MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * t;\n            Hit res = sceneSDF(p); \n            float dist = res.dist * signInd;\n            \n            if (dist < 0.0 )\n            {\n                return result;\n            }\n            else if (t > tmax)\n            {\n                result.matIndex = -1;\n                result.dist = tmax;\n                break;\n            }\n            \n            t += max(dist, EPSILON); //faster than abs()\n            result.dist = t;\n            result.matIndex = res.matIndex;\n        }\n        \n        return result;\n    }\n\n    vec3 background(vec2 p) \n    {\n        return vec3(0.0);//mix(vec3(0.2, 0.5, 0.5), vec3(0.4, 0.3, 0.3), pow(0.8, (p.y + 0.5) * 0.1));\n    }\n\n    vec3 getColor(vec3 ro, vec3 p, vec3 nor, int matIdx, in Material mat) {\n        vec3 col = vec3(0.0);\n        vec3 N = nor;\n        vec3 V = normalize(ro - p);\n        vec3 L = normalize(lightInfo.position - p);\n        vec3 R = reflect(-L, N);\n        float spec = pow(max(dot(V, R), 0.0), mat.specular);\n        \n        // floor\n        if (matIdx < 1 && N.y > 0.5) {\n            mat.albedo = mix(vec3(0.0), vec3(0.95), mod(floor(p.x * 0.3) + floor(p.z * 0.3), 2.0));\n        } \n        vec3 ambient = vec3(0.1) * mat.albedo;\n        col += ambient;\n        \n        col += float(matIdx) * spec * lightInfo.color; \n        \n        return col;\n    }\n\n    mat3 getCamera( in vec3 ro, in vec3 ta) {\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(0.0, 1.0, 0.0);\n        vec3 cu = normalize( cross(cw,cp) );\n        vec3 cv =          ( cross(cu,cw) );\n        return mat3( cu, cv, cw );\n    }\n\n    //hacks for non-constant index expression\n    Material getMaterial(int index) {\n        Material mat[4];\n        mat[0] = Material(vec3(0.6, 0.75, 0.8), 0.5, 16.0, 0.8, 0.0); \n        mat[1] = Material(vec3(1.0, 0.5, 0.5), 0.1, 128.0, 0.4, 0.9); \n        mat[2] = Material(vec3(0.1,0.1,0.2), 0.1, 128.0, 0.4, 0.9); \n        mat[3] = Material(vec3(0.2, 0.6, 0.6), 0.1, 128.0, 0.4, 0.9); \n        if (index == 0) {\n            return mat[0];\n        } else if (index == 1) {\n            return mat[1];\n        } else if (index == 2) {\n            return mat[2];\n        } else if (index == 3) {\n            return mat[3];\n        }\n    }\n\n    vec3 reflectionRay(in vec3 ori, in vec3 dir, in vec3 backColor, in vec3 pixColor, inout vec3 att) {\n        for (float i = 0.0; i < 2.0; i++) {\n            Hit icp = marching(ori, dir, 1.0);\n            vec3 interP = ori + icp.dist * dir; \n            vec3 nor = getNormal(interP);\n            Material mat = getMaterial(icp.matIndex);\n            if (icp.matIndex < 0) {\n                pixColor += vec3(0.0);//mix(pixColor, backColor, att);\n            } else {\n                vec3 localColor = getColor(ori, interP, nor, icp.matIndex, mat); \n                pixColor = mix(pixColor, localColor, att);\n                dir = reflect(dir, nor);\n                ori = interP + dir * EPSILON;\n                att *= mat.reflection;\n            }\n        }\n        return pixColor;\n    }\n    vec3 refractionRay(in vec3 ori, in vec3 dir, in vec3 backColor, in vec3 pixColor, in float refractionRatio, inout float signInd, inout vec3 att) {\n        for (float i = 0.0; i < 4.0; i++) {\n            Hit icp = marching(ori, dir, signInd);\n            vec3 interP = ori + icp.dist * dir; \n            vec3 nor = signInd * getNormal(interP);\n            Material mat = getMaterial(icp.matIndex);\n            if (icp.matIndex < 0) {\n                pixColor += vec3(0.0); //mix(pixColor, backColor, att);\n            } else {\n                if (signInd > 0.0) { \n                    vec3 localColor = getColor(ori, interP, nor, icp.matIndex, mat); \n                    pixColor = mix(pixColor, localColor, att);\n                }\n                \n                vec3 refractDir = refract(dir, nor, refractionRatio);\n                vec3 reflectDir = reflect(dir, nor);\n                \n                if (dot(refractDir, refractDir) < EPSILON ) {\n                    //total internal reflection\n                    dir = reflectDir;\n                    ori = interP + dir * EPSILON;\n                    att *= mat.reflection;\n                } else {\n                    //flip normal direction and refractionRatio for the next ray\n                    dir = refractDir;\n                    ori = interP + dir * EPSILON;\n                    signInd = -signInd;\n                    refractionRatio = 1.0/ refractionRatio;\n                    att *= mat.refraction; \n                } \n            }\n        }\n        return pixColor;\n    }\n\n    void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n        vec2 uv = v_texCoord;\n        uv -= 0.5; \n        uv.x *= iResolution.x/iResolution.y;  \n    \n        vec3 col = vec3(0.0);\n        vec2 mouse = vec2(0.01) + iMouse.xy/iResolution.xy;\n        mouse.x -= 0.5;\n        float rot = mouse.x + iTime*0.05;\n        vec3 ro = vec3(-20.0 * cos(rot * 2.0 * PI), 2.0+8.0 * mouse.y, -20.0 * sin(rot * 2.0 * PI));\n        vec3 ta = vec3(0.0, 2.0, -2.0);\n        mat3 cam = getCamera(ro, ta);\n        vec3 rd = normalize(cam * vec3(uv, 1.0));\n        \n        vec3 nor = vec3(0.0);  \n        vec3 ori = ro;\n        vec3 dir = rd;\n        vec3 interP = vec3(0.0);\n        float signInd = 1.0;\n        vec3 reflectDir = vec3(0.0);\n        vec3 refractDir = vec3(0.0);\n        float refractionRatio = 1.0/1.4;\n        vec3 localColor = vec3(0.0);\n        vec3 f0 = vec3(0.03);\n        vec3 refractAtt = vec3(1.0);\n        vec3 reflectAtt = vec3(1.0);\n        vec3 refractCol = vec3(0.0);\n        vec3 reflectCol = vec3(0.0);\n        \n        //initial ray\n        Hit icp = marching(ori, dir, 1.0); //reserved for future use\n        Hit initRay = icp;\n        interP = ori + icp.dist * dir; \n        nor = signInd * getNormal(interP);\n        Material mat = getMaterial(icp.matIndex);\n        vec3 backColor = background((ori + MAX_DISTANCE * dir).xy);\n        if (icp.matIndex < 0) {\n            col += vec3(0.0);\n        } else {\n            col += getColor(ori, interP, nor, icp.matIndex, mat);\n        }\n        \n        refractDir = refract(dir, nor, refractionRatio);\n        reflectDir = reflect(dir, nor);\n        \n        //reflection ray\n        dir = reflectDir;\n        ori = interP + dir * EPSILON;\n        reflectAtt *= mat.reflection;\n        reflectCol = reflectionRay(ori, dir, backColor, col, reflectAtt);\n        \n        //refraction ray\n        if (dot(refractDir, refractDir) < EPSILON ) {\n            //total internal reflection\n            dir = reflectDir;\n            ori = interP + dir * EPSILON;\n        } else {\n            //flip normal direction and refractionRatio for the next ray\n            dir = refractDir;\n            ori = interP + dir * EPSILON;\n            signInd = -signInd;\n            refractionRatio = 1.0/refractionRatio;\n        }\n        refractAtt *= mat.refraction;\n        refractCol = refractionRay(ori, dir, backColor, col, refractionRatio, signInd,refractAtt);\n        \n        col = reflectCol + refractCol;\n        \n        col = pow(col, vec3(1.0/2.2)); \n        fragColor = vec4(col,1.0);\n    }\n\n    void main() {\n        mainImage(fragColor, gl_FragCoord.xy);\n    }\n"},_={vertex:f,fragment:"#version 300 es\n    precision mediump float;\n\n    uniform vec2 u_mouse;\n    uniform float u_time;\n    uniform vec2 u_resolution;\n    \n    in vec2 v_texCoord;\n    in vec3 v_normal;\n    in vec4 v_fragPos;\n    out vec4 fragColor;\n\n    // Convert to shadertoy namings\n    #define iMouse u_mouse\n    #define iResolution u_resolution\n    #define iTime u_time\n\n    \n    //noise function from iq: https://www.shadertoy.com/view/Msf3WH\n    vec2 hash( vec2 p ) \n    {\n        p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n        return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    }\n\n    float noise( in vec2 p )\n    {\n        const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n        const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n        vec2  i = floor( p + (p.x+p.y)*K1 );\n        vec2  a = p - i + (i.x+i.y)*K2;\n        float m = step(a.y,a.x); \n        vec2  o = vec2(m,1.0-m);\n        vec2  b = a - o + K2;\n        vec2  c = a - 1.0 + 2.0*K2;\n        vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n        vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n        return dot( n, vec3(70.0) );\n    }\n\n    const mat2 m2 = mat2(1.6,  1.2, -1.2,  1.6);\n\n    float fbm4(vec2 p) {\n        float amp = 0.5;\n        float h = 0.0;\n        for (int i = 0; i < 4; i++) {\n            float n = noise(p);\n            h += amp * n;\n            amp *= 0.5;\n            p = m2 * p ;\n        }\n        \n        return  0.5 + 0.5*h;\n    }\n\n    void mainImage( out vec4 fragColor, in vec2 fragCoord )\n    {\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord/iResolution.xy;\n        uv -= 0.5;\n        uv.x *= iResolution.x/iResolution.y;\n        vec2 mo = iMouse.xy/iResolution.xy;\n        vec3 sky = vec3(0.5, 0.7, 0.8);\n        vec3 col = vec3(0.0);\n        \n        // speed\n        float v = 0.001;\n\n        // layer1\n        vec3 cloudCol = vec3(1.0);\n        uv += mo * 10.0;\n    \n        vec2 scale = uv * 2.0;\n        vec2 turbulence = 0.008 * vec2(noise(vec2(uv.x * 10.0, uv.y *10.0)), noise(vec2(uv.x * 10.0, uv.y * 10.0)));\n        scale += turbulence;\n        float n1 = fbm4(vec2(scale.x - 20.0 * sin(iTime * v * 2.0), scale.y - 50.0 * sin(iTime * v)));\n        col = mix( sky, cloudCol, smoothstep(0.5, 0.8, n1));\n        \n        //layer2\n        scale = uv * 0.5;\n        turbulence = 0.05 * vec2(noise(vec2(uv.x * 2.0, uv.y * 2.1)), noise(vec2(uv.x * 1.5, uv.y * 1.2)));\n        scale += turbulence;\n        float n2 = fbm4(scale + 20.0 * sin(iTime * v ));\n        col =  mix( col, cloudCol, smoothstep(0.2, 0.9, n2));\n        col = min(col, vec3(1.0));\n        \n        \n        // Output to screen\n        fragColor = vec4(col, 1.0);\n    }\n    void main() {\n        mainImage(fragColor, gl_FragCoord.xy);\n    }\n"},A={vertex:f,fragment:"#version 300 es\n    precision mediump float;\n\n    uniform vec2 u_mouse;\n    uniform float u_time;\n    uniform vec2 u_resolution;\n    uniform samplerCube u_cubemap;\n    in vec2 v_texCoord;\n    in vec3 v_normal;\n    in vec4 v_fragPos;\n    out vec4 fragColor;\n\n    // Convert to shadertoy namings\n    #define iMouse u_mouse\n    #define iResolution u_resolution\n    #define iTime u_time\n\n    const float EPSILON = 0.0001;\n    const float PI = 3.1415926;\n    const float MAX_DIST = 100.0;\n    const int MAX_STEPS = 60;\n    const vec3 LIGHTBLUE = vec3(154.0, 247.0, 247.0)/255.0;\n    const vec3 GREEN = vec3(125.0, 245.0, 217.0)/255.0;\n    const vec3 YELLOW = vec3(0.2, 0.2, 0.0);\n    const vec3 PINK = vec3(255.0, 94.0, 186.0)/255.0;\n\n    struct Material {\n        vec3 ambient;\n        vec3 diffuse;\n        vec3 specular;\n        float shiness;\n    };\n\n    #define BLINN 1\n    #define AA 0\n\n    float sphereSDF(vec3 p, float r) {\n        return length(p) - r;\n    }\n\n    float sdTorus( vec3 p, vec2 t )\n    {\n        return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n    }\n\n    vec2 intersectSDF(vec2 dist0, vec2 dist1) {\n        return dist0.x > dist1.x? dist0 : dist1;\n    }\n\n    vec2 unionSDF(vec2 dist0, vec2 dist1) {\n        return dist0.x < dist1.x? dist0 : dist1;\n    }\n\n    vec2 diffSDF(vec2 dist0, vec2 dist1) {\n        return dist0.x > -dist1.x? dist0 : vec2(-dist1.x, dist1.y);\n    }\n\n    vec3 rotX(vec3 p, float d) {\n        mat4 rotM= mat4(1.0, 0.0, 0.0, 0.0, \n                        0.0, cos(d), -sin(d), 0.0, \n                        0.0, sin(d), cos(d), 0.0, \n                        0.0, 0.0, 0.0, 1.0);\n        return vec3(rotM * vec4(p, 1.0));\n    }\n    vec3 rotY(vec3 p, float d) {\n        mat4 rotM= mat4(cos(d), 0.0, sin(d), 0.0, \n                        0.0, 1.0, 0.0, 0.0,\n                        -sin(d), 0.0, cos(d), 0.0, \n                        0.0, 0.0, 0.0, 1.0);\n        return vec3(rotM * vec4(p, 1.0));\n    }\n\n    vec3 rotZ(vec3 p, float d) {\n        mat4 rotM= mat4(cos(d), -sin(d), 0.0, 0.0, \n                        sin(d), cos(d), 0.0, 0.0, \n                        0.0, 0.0, 1.0, 0.0, \n                        0.0, 0.0, 0.0, 1.0);\n        return vec3(rotM * vec4(p, 1.0));\n    }\n\n    vec3 doTranslate(vec3 p, vec3 t) {\n        return p - t;\n    }\n\n    vec2 sceneSDF(vec3 p) {\n        float deg = 90.0;\n        float sr = 2.0;\n        float lr = 2.0;\n        float SR = 1.8;\n        float LR = 1.5;\n        float spheres[12];\n        float vTime = iTime;\n        \n        float id = 1.0;\n        for (int i = 0; i < 4; i ++) {\n            float dx = SR * cos(90.0 * id * PI / 180.0);\n            float dz = SR * sin(90.0 * id * PI / 180.0);\n            vec3 v = vec3(p.x + dx, p.y, p.z + dz);\n            spheres[i] = sphereSDF(v, sr);\n            id += 1.0;\n        }\n        spheres[4] = sphereSDF(vec3(p.x, p.y + LR, p.z), lr);\n        spheres[5] = sphereSDF(vec3(p.x, p.y - LR, p.z), lr);\n        \n        \n        \n        float torus[3];\n        float t_ry = 0.1;\n        float t_rxl = 16.0;\n        float t_rxs = 12.0;\n        float alpha0 = vTime;\n        float alpha1 = vTime + 90.0 * PI / 180.0;\n        torus[0] = sdTorus( rotX(p, alpha0), vec2(t_rxl, t_ry) );\n        torus[1] = sdTorus( rotZ(p, alpha0), vec2(t_rxs, t_ry) );\n        torus[2] = sdTorus( rotZ(p, alpha1), vec2(t_rxs, t_ry) );\n        \n        float ssr = 0.3;\n        spheres[6] = sphereSDF(vec3(p.x, p.y - t_rxl * sin(alpha0), p.z + t_rxl * cos(alpha0)), ssr);\n        spheres[7] = sphereSDF(vec3(p.x, p.y + t_rxl * sin(alpha0), p.z - t_rxl * cos(alpha0)), ssr);\n        spheres[8] = sphereSDF(vec3(p.x - t_rxl, p.y, p.z), ssr);\n        spheres[9] = sphereSDF(vec3(p.x + t_rxl, p.y, p.z), ssr);\n        \n        spheres[10] = sphereSDF(vec3(p.x - t_rxs * cos(alpha0), p.y - t_rxs* sin(alpha0), p.z), ssr);\n        spheres[11] = sphereSDF(vec3(p.x - t_rxs * cos(alpha1), p.y - t_rxs* sin(alpha1), p.z), ssr);\n        \n        float objId = 0.0;\n        //horizontal spheres\n        vec2 combined = unionSDF(vec2(spheres[0], objId), vec2(spheres[1], objId));\n        combined = unionSDF(combined, vec2(spheres[2], objId));\n        combined = unionSDF(combined, vec2(spheres[3], objId));\n        \n        //lower sphere\n        objId++;\n        combined = unionSDF(combined, vec2(spheres[4], objId));\n        \n        //upper sphere\n        objId++;\n        combined = unionSDF(combined, vec2(spheres[5], objId));\n        \n        //small spheres\n        objId++;\n        combined = unionSDF(combined, vec2(spheres[6], objId));\n        combined = unionSDF(combined, vec2(spheres[7], objId));\n        combined = unionSDF(combined, vec2(spheres[8], objId));\n        combined = unionSDF(combined, vec2(spheres[9], objId));\n        combined = unionSDF(combined, vec2(spheres[10], objId));\n        combined = unionSDF(combined, vec2(spheres[11], objId));\n        \n        //large tortus\n        objId++;\n        combined = unionSDF(combined, vec2(torus[0], objId));\n        \n        //small tortus\n        objId++;\n        combined = unionSDF(combined, vec2(torus[1], objId));\n        combined = unionSDF(combined, vec2(torus[2], objId));\n        \n    \n        \n    return combined;\n    }\n\n    vec2 rayMarching(vec3 ro, vec3 rd) {\n        float tmax = MAX_DIST;\n        float t = 0.0;\n        vec2 result = vec2(-1.0);\n        \n        for (int i = 0; i < MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * t;\n            vec2 res = sceneSDF(p);\n            if (res.x < EPSILON || t > tmax) break;\n            result.x = t;\n            result.y = res.y;\n            t += res.x;\n        }\n        if (t > tmax) {\n            result.x = tmax;\n            result.y = -1.0;\n        }\n        return result;\n    }\n\n    const vec3 AMBIENT_COLOR = vec3(0.1);\n    const vec3 DIFFUSE_COLOR = vec3(0.6);\n    const vec3 SPEC_COLOR = vec3(0.5);\n    const vec3 LIGHT_COLOR = vec3(1.0, 1.0, 0.0);\n\n    vec3 shading(vec3 normal, vec3 viewDir, vec3 lightDir, Material mat) {\n        \n        vec3 ambCol = AMBIENT_COLOR * mat.ambient;\n        vec3 V = normalize(viewDir);\n        vec3 L = normalize(lightDir);\n        vec3 N = normalize(normal);\n        float diff = max(dot(N, L), 0.0);\n        vec3 diffCol = DIFFUSE_COLOR * diff * mat.diffuse;\n        \n        vec3 R = normalize(reflect(-L, N));  \n        vec3 VR = normalize(reflect(-V, N)); \n        \n    #if BLINN == 1\n        vec3 H = normalize(L + V);\n        float spec = pow(max(dot(N, H), 0.0), mat.shiness);\n    #else    \n        \n        float spec = pow(max(dot(V, R), 0.0), mat.shiness);\n    #endif   \n        \n        vec3 speCol = SPEC_COLOR * spec * mat.specular;\n        \n        vec3 refl = texture(u_cubemap, VR).rgb;\n        \n        return refl * mat.diffuse + speCol;\n    }\n\n    mat3 getCamera( in vec3 ro, in vec3 ta, float cr )\n    {\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(cr), cos(cr),0.0);\n        vec3 cu = normalize( cross(cw,cp) );\n        vec3 cv =          ( cross(cu,cw) );\n        return mat3( cu, cv, cw );\n    }\n\n    vec3 getNormals(vec3 p) {\n        float x = sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).x - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).x;\n        float y = sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).x - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).x;\n        float z = sceneSDF(vec3(p.x, p.y, p.z + EPSILON)).x - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).x;\n        return normalize(vec3(x, y, z));\n    }\n\n    vec3 background(vec2 p) {\n        return mix(YELLOW, GREEN, p.y + 0.5);\n    }\n\n    vec3 render(in vec2 fragCoord) {\n    vec2 uv = v_texCoord;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3 (cos(iTime) * 10.0 + 10.0, 3.0, sin(iTime) * 10.0 + 20.0);\n    //vec3 ro = vec3 (0.0, 5.0, 25.0);\n    vec3 ta = vec3 (0.0, 0.0, -1.0);\n    mat3 cam = getCamera(ro, ta, 0.0);\n    \n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n    vec2 h = rayMarching(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    if (h.x < MAX_DIST) {\n        \n        vec3 p = ro + rd * h.x;\n        vec3 nor = getNormals(p);\n        vec3 lightPos = vec3(20.0 * sin(iTime), 10.0, -20.0);\n        vec3 lightDir = lightPos - p;\n        vec3 viewDir = ro - p;\n            \n        Material mat;\n        //chrome\n        mat.ambient = vec3(0.25);\n        mat.diffuse = vec3(0.5);\n        mat.specular = vec3(0.674597);\n        mat.shiness = 1.2;\n        \n        if (h.y == 1.0 || h.y == 2.0) {\n            //pink\n            mat.ambient = PINK;\n            mat.diffuse = PINK;\n            mat.specular = PINK;\n        } else if (h.y == 0.0) {\n            //gold\n            mat.ambient = vec3(0.24725, 0.1995, 0.0745);\n            mat.diffuse = vec3(0.75164, 0.60648, 0.12648);\n            mat.specular = vec3(0.628281, 0.555802, 0.366065);\n            mat.shiness = 1.2;\n        } \n        col += shading(nor, viewDir, lightDir, mat) ;\n    } else {\n        col = background(uv);\n    }\n        return col;\n    }\n\n    void mainImage (out vec4 fragColor, in vec2 fragCoord)\n    {\n        vec3 col = vec3(0.0);\n    #if AA > 1\n        float count = 0.0;\n        for (float aaY = 0.0; aaY < float(AA); aaY++)\n        {\n            for (float aaX = 0.0; aaX < float(AA); aaX++)\n            {\n                col += render(fragCoord + vec2(aaX, aaY) / float(AA));\n                count += 1.0;\n            }\n        }\n        col /= count;\n    #else\n        col += render(fragCoord);\n    #endif\n        \n        col = pow( col, vec3(1.0/2.2) );\n        \n        \n        vec2 p = v_texCoord;\n        col *= 0.2 + 0.8 * pow(32.0 * p.x * p.y * (1.0 - p.x) * (1.0 - p.y), 0.2);\n        \n        fragColor = vec4 (col, 1.);\n    }\n\n    void main() {\n        mainImage(fragColor, gl_FragCoord.xy);\n    }\n"},w={vertex:f,fragment:"#version 300 es\nprecision mediump float;\n\nuniform vec2 u_mouse;\nuniform float u_time;\nuniform vec2 u_resolution;\n\nin vec2 v_texCoord;\nin vec3 v_normal;\nin vec4 v_fragPos;\nout vec4 fragColor;\n\n// Convert to shadertoy namings\n#define iMouse u_mouse\n#define iResolution u_resolution\n#define iTime u_time\n\n#define ITERATION 12\n#define PI 3.1416\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*v_texCoord - 1.0;\n    uv.x *= iResolution.x/iResolution.y; \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float ti = iTime * 0.2;\n    ivec2 txy = ivec2(fragCoord.xy/iResolution.xy);\n    vec2 c = vec2(0.45*cos(PI*mo.x + ti*0.5), 0.45*sin(PI*mo.y + ti*0.5));\n    c += 0.5;\n    \n    vec2 p = uv;  \n    float len = length(p);\n    float r = 0.0, g = 0.0, b = 0.0;\n    \n \tvec3 col = vec3(0.0);\n    for (int i = 0; i < ITERATION; ++i) {\n        p = abs(p)/dot(p,p) - c;\n        float l = len;\n        len = length(p);\n        l = len - l;\n        \n        col +=  l * len * vec3(sin(1.2*ti + 10.0), cos(1.8*ti + 12.0), sin(-1.2*ti));\n    \tcol = 1.0 - exp(-0.04*col);\n    }\n    \n    col = pow(col, vec3(1.0/2.2));\n    // Output to screen\n    fragColor = vec4(col ,1.0);\n}\n\nvoid main() {\n    mainImage(fragColor, gl_FragCoord.xy);\n}\n\n"},E={vertex:f,fragment:"#version 300 es\nprecision mediump float;\n\nuniform vec2 u_mouse;\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform samplerCube u_cubemap;\nuniform sampler2D u_sample;\n\nin vec2 v_texCoord;\nin vec3 v_normal;\nin vec4 v_fragPos;\nout vec4 fragColor;\n\n// Convert to shadertoy namings\n#define iMouse u_mouse\n#define iResolution u_resolution\n#define iTime u_time\n\n#define PI 3.1415926\n#define EPSILON 0.001\nconst int MAX_STEPS = 120;\nconst float MAX_DISTANCE = 100.0;\nconst float AA_SIZE = 2.0;\nconst vec3 LIGHT_COLOR = vec3(1.0, 1.0, 1.0);\n\nvec3 light_position;\n\nfloat plane(vec3 p) \n{\n    return p.y;\n}\n\nfloat displacement (vec3 p) \n{\n    return sin(p.y) * 1.5;\n}\n\nfloat sphereSDF(vec3 p, float r) \n{\n    return length(p) - r;\n}\n\nfloat dot2(in vec2 v) {\n    return dot(v, v);\n}\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec2 unionSDF(vec2 d1, vec2 d2) \n{\n    return d1.x < d2.x? d1 : d2;\n}\n\nvec3 doTranslate(vec3 p, vec3 offset) \n{\n    return p - offset;\n}\n\nvec2 sceneSDF(vec3 p) \n{\n    vec2 result0 = vec2(plane(p), -1.0);\n    \n    vec3 p1= doTranslate(p,vec3(0.0, 3.0 , 0.0));\n    vec2 result1 = vec2(sphereSDF( p1 , 2.5) + displacement(p1), 2.0);\n    result1.x *= 0.5;\n    \n    vec3 p2= doTranslate(p,vec3(3.0, 3.5 , 0.0));\n    vec2 result2 = vec2(sphereSDF( p2 , 2.5), 2.0);\n    \n    vec3 p3 = doTranslate(p,vec3(0.0, 0.0 , 0.0));\n    vec2 result3 = vec2(sdCappedCone(p3, 1.5, 3.0, 2.2), 3.0);  \n    \n    \n    vec2 result = unionSDF(result0, result1);\n    //result = unionSDF(result, result2);\n    //result = unionSDF(result, result3);\n    return result;\n}\n\nvec2 marching(vec3 ro, vec3 rd) \n{\n    float tmax = MAX_DISTANCE;\n    float t = 0.001;\n    vec2 result = vec2(-1.0);\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        vec2 res = sceneSDF(p);\n        if (res.x < EPSILON)\n        {\n            return result;\n        }\n        else if (t > tmax)\n        {\n            result.y = -1.0;\n            result.x = tmax;\n            break;\n        }\n        t += res.x;\n        result.x = t;\n        result.y = res.y;\n    }\n    \n    return result;\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd) {\n    float mint = 0.1;\n    float t = mint;\n    float res = 1.0;\n    float k = 4.0;\n    for (int i = 0; i < 40; i++)\n    {\n        float h = sceneSDF(ro + rd * t).x;\n        \n\t\tres = min( res, k * h / t );\n        t += clamp( h, 0.02, 0.20 );\n     \n        if ( h < EPSILON ) \n        {\n            res = min(res, 0.0);\n            break;\n        } \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    //float k = 5.0; \n    float h = 0.001;\n    for( float i = 0.0; i < 5.0; i++ )\n    {\n        float d = sceneSDF( pos + h * nor ).x;\n        occ += ( h - d ) * sca;\n        sca *= 0.9;\n        h += 0.45 * i / 5.0;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec2 OFFSET = vec2(EPSILON, 0.0);\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(p + OFFSET.xyy).x - sceneSDF(p - OFFSET.xyy).x,\n        sceneSDF(p + OFFSET.yxy).x - sceneSDF(p - OFFSET.yxy).x,\n        sceneSDF(p + OFFSET.yyx).x - sceneSDF(p - OFFSET.yyx).x\n    ));\n}\n\nvec3 shading(vec3 ro, vec3 p, float objId) \n{\n    vec3 outCol = vec3(0.0);\n    vec3 lightPos = light_position; \n    vec3 viewDir = ro - p;\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    \n    vec3 nor = vec3(0.0);\n    nor = getNormal(p);\n    vec3 diffCol = LIGHT_COLOR;\n    if (objId == -1.0) \n    {//floor\n        vec2 offset = vec2(0.002, 0.0);\n        vec2 floorUV = p.xz * 5.0/MAX_DISTANCE;\n        diffCol = texture(u_sample, floorUV).rgb; \n        float dx = texture(u_sample, floorUV + offset.xy).r \n            \t - texture(u_sample, floorUV - offset.xy).r ;\n        float dz = texture(u_sample, floorUV + offset.yx).r \n            \t - texture(u_sample, floorUV - offset.yx).r ;\n        nor = normalize(vec3(dx, 1.0, dz ));\n    } \n    vec3 N = nor;\n    vec3 I = normalize(viewDir);\n    vec3 L = normalize(lightDir);\n    vec3 R = normalize(reflect(-L, N));\n    vec3 RV = normalize(reflect(-I, N));\n\n    float ao = calcAO(p, N) ;\n    vec3 ambient = LIGHT_COLOR * ao * 0.3;\n    float diff = max(dot(L, N), 0.0);\n    float sd = calcShadow(p, normalize(lightPos));\n     \n    vec3 diffuse = diffCol * diff * sd * 0.5 ;\n    float spec = pow(max(dot(I, R), 0.0), 16.0);\n    vec3 specular = LIGHT_COLOR * spec * 0.8;\n    outCol = LIGHT_COLOR * (ambient + diffuse + specular);\n    \n    //reflection + refraction\n    vec3 refl = texture(u_cubemap, RV).rgb;\n    \n    float refractRatio = 0.95;\n    float fresnelBias = 0.0;\n    float fresnelPow = 0.2;\n    float fresnelScale = 1.0;\n    float reflectionFactor = clamp(fresnelBias + fresnelScale * pow( 1.0 + dot( -I, N ), fresnelPow ), 0.0, 1.0);\n        \n    vec3 refractR = normalize(refract(-I, N, refractRatio));\n    vec3 refractG = normalize(refract(-I, N, refractRatio * 0.98));\n    vec3 refractB = normalize(refract(-I, N, refractRatio * 0.96));\n    \n    float level = smoothstep(0.8, 1.2, p.y); //adding a bit blur\n    //if (p.y > 1.0)\n    //{\n        vec3 refractCol = vec3(1.0);\n        refractCol.r = texture(u_cubemap, refractR).r;\n        refractCol.g = texture(u_cubemap, refractG).g;\n        refractCol.b = texture(u_cubemap, refractB).b;\n        vec3 fr = mix(refl, refractCol, reflectionFactor);\n        outCol = mix(outCol, fr, level);\n    //}\n    \n    return outCol;\n}\n\nmat3 getCamera( in vec3 ro, in vec3 ta)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render(in vec2 fragCoord) \n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; // translate to the center of the screen\n    uv.x *= iResolution.x/iResolution.y; // restore aspect ratio\n    \n    vec3 col = vec3(0.0);\n    vec2 mouse = vec2(0.01) + iMouse.xy  / iResolution.xy ;\n    mouse -= 0.5;\n    float t = iTime * 0.1;\n    \n    vec3 ro = vec3(10.0 * cos(mouse.x * 2.0 * PI + t), 2.0 + mouse.y * 4.0, 10.0 * sin(mouse.x * 2.0 * PI + t));\n    //vec3 ro = vec3(0.0, 5.0, 10.0);\n    vec3 ta = vec3(0.0, 2.0, 0.0);\n    mat3 cam = getCamera(ro, ta);\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n    \n    vec2 h = marching(ro, rd);\n    vec3 p = ro + rd * h.x;\n    if (h.x < MAX_DISTANCE) \n    {\n        col += shading(ro, p, h.y);\n    } else \n    {\n        col += texture(u_cubemap, rd).rgb;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    float count = 0.0;\n    light_position = vec3(0.0, 10.0, 4.0);\n    for (float aay = 0.0; aay < AA_SIZE; aay++) \n    {\n        for (float aax = 0.0; aax < AA_SIZE; aax++) \n        {\n            col += render(fragCoord + vec2(aax, aay)/AA_SIZE);\n            count++;\n        }\n    }\n    \n    col /= count;\n    fragColor = vec4(col, 1.0);\n}\nvoid main() {\n    mainImage(fragColor, gl_FragCoord.xy);\n}\n\n"},S={vertex:f,fragment:"#version 300 es\nprecision mediump float;\n\nuniform vec2 u_mouse;\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform samplerCube u_cubemap;\n\nin vec2 v_texCoord;\nin vec3 v_normal;\nin vec4 v_fragPos;\nout vec4 fragColor;\n\n// Convert to shadertoy namings\n#define iMouse u_mouse\n#define iResolution u_resolution\n#define iTime u_time\n\n#define PI 3.1415926\n#define MAX_STEP 60\n#define MAX_DIST 40.0\n#define EPSILON 0.0001\n#define GLOW_COLOR0 vec3(1.0,0.0,0.3)\n#define GLOW_COLOR1 vec3(0.0,0.3,1.0)\n#define SURFACE_COLOR vec3(0.0,1.0,1.0)\n#define AA 2\nfloat sdSphere( in vec3 pos, in float r )\n{\n    return length(pos) - r;\n}\n\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nvec2 opUnion( vec2 d1, vec2 d2 ) \n{  \n    return d1.x<d2.x? d1:d2; \n}\n\nvec3 map( in vec3 pos )\n{\n    vec3 p = pos;\n    \n    vec2 d0 = vec2(sdOctahedron(p,3.0), 1.0);\n    \n    vec2 d1 = vec2(sdSphere( p-vec3(0.0,1.2,0.0),2.0 ), 2.5);\n    d1 += 0.2*sin(2.0*p.x+iTime);\n    d1 *= 0.8;\n    \n    \n    d0 = opUnion(d0, d1);\n    \n    \n    vec3 rst = vec3(d0, 0.0);\n    \n    return rst;\n}\n\nvec3 raymarch( in vec3 ro, in vec3 rd )\n{\n    vec3 rst = vec3(0.0, -1.0, MAX_DIST);\n    float t = 0.01;\n    float minDist = MAX_DIST;\n    for ( int i = 0; i < MAX_STEP; ++i )\n    {\n        vec3 p = ro + t * rd;\n        vec3 dist = map(p);\n        minDist = min(minDist, dist.x/t);\n        if ( abs(dist.x)<EPSILON || t>MAX_DIST) break;\n        \n        t += dist.x; \n        rst = vec3(t, dist.y, minDist);\n    }\n    \n    if ( t>MAX_DIST )\n    {\n        rst= vec3(MAX_DIST, -1.0, minDist);\n    }\n    \n    return rst;\n}\n\nvec3 getNormal( in vec3 pos )\n{\n    vec2 offset = vec2(EPSILON, 0.0);\n    return normalize( vec3(map(pos+offset.xyy).x - map(pos-offset.xyy).x,\n                           map(pos+offset.yxy).x - map(pos-offset.yxy).x,\n                           map(pos+offset.yyx).x - map(pos-offset.yyx).x) );\n}\n\nvec3 shading( in vec3 ro, in vec3 rd, in vec3 hit, in vec3 pixCol )\n{\n    vec3 outCol = vec3(0.0);\n    vec3 pos = ro+hit.x*rd;\n    vec3 nor = getNormal(pos);\n    vec3 lightDir = normalize(vec3(0.5, 0.5, 0.5));\n    float diff = max(dot(lightDir, nor), 0.0);\n    if (hit.y == 1.0)\n    {\n        outCol += SURFACE_COLOR*diff;\n    } else\n    {\n        outCol += pixCol*SURFACE_COLOR;//sphere\n    }\n    return outCol;\n}\n\nmat3 getCamera( in vec3 ta, in vec3 ro )\n{\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0,1.0,0.0)));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu,vv,ww);\n}\n\nvec3 render( in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = u_texCoord;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float aTime = iTime*0.4;\n    vec3 ro = vec3(8.0*cos(aTime+mouse.x*6.28),mouse.y*2.0,8.0*sin(aTime+mouse.x*6.28));\n    vec3 ta = vec3(0.0,0.0,0.0);\n    mat3 cam = getCamera(ta,ro);\n    vec3 rd = cam*(vec3(uv,0.9));\n    \n    vec3 tex = texture(u_cubemap,rd).rgb;\n    vec3 backCol = vec3(tex.r*tex.g*tex.b);\n    col += backCol*backCol*backCol;\n    vec3 hit = raymarch(ro,rd);\n       \n    if ( hit.y>0.0 )\n    {\n        col = shading( ro, rd, hit, col )*2.0;\n    }\n    float glow0 = exp(-24.0*hit.z);\n    float glow1 = exp(-16.0*hit.z);\n    vec3 glowCol = vec3(0.0);\n    float t = fract(iTime*0.5);\n    float y = 3.0*t*(1.0-t); \n    \n    glowCol += 0.5*GLOW_COLOR1*glow0*y;  \n    glowCol += 0.5*GLOW_COLOR1*glow1; \n    glowCol += 0.2*GLOW_COLOR0*exp(-8.0*hit.z); \n    \n    glowCol *= 0.5+0.5*y;\n    return col+glowCol*0.8;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col = vec3(0.0);\n    for ( float j = 0.0; j < float(AA); ++j )\n    {\n        for ( float i = 0.0; i < float(AA); ++i )\n        {\n            vec2 off = -0.5+vec2(j,i)/float(AA);\n            col += render(fragCoord+off);\n        }\n    }\n    \n    col /= float(AA*AA);\n    \n    col = pow( col, vec3(0.4546));\n    // vignetting        \n    vec2 q = v_texCoord;\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n    \n    fragColor = vec4(col,1.0);\n}\n\nvoid main() {\n    mainImage(fragColor, gl_FragCoord.xy);\n}\n\n"};var T=t(8893),I=t(6524),D=t(4003),R=t(6307),P=t(2742),O=t(4200),k=t(4370),F=t(3111),M=t(8109),L=t(6871),N=t(600),z=t(4475),U=t(4470),B=t(9243),j=t(4732),X=t(8014),G=t(7811),H=t(8216),q=t(7896),V=t(8226),W=t(7035),Y=t(9684),Z=t(7933),K=t(6141),$=t(3674),J=t(4240),Q=t(4013),nn=t(6359),en=t(4900),tn=t(1297);function on(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,o)}return t}function rn(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?on(Object(t),!0).forEach((function(e){i()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):on(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var an={shaders:{"3D":{FinalPass:u,SimpleColor:{vertex:"#version 300 es\n  precision mediump float;\n  uniform mat4 u_model;\n  uniform mat4 u_view;\n  uniform mat4 u_projection;\n  uniform mat4 u_normalMatrix;\n\n  in vec4 a_position;\n  in vec3 a_normal;\n  in vec2 a_texCoord;\n\n  out vec2 v_texCoord;\n  out vec3 v_normal;\n  out vec3 v_fragPos;\n\n  void main(){\n    gl_Position = u_projection * u_view * u_model * a_position;\n    v_normal = mat3(u_normalMatrix) * a_normal; //Transform to world space\n    v_fragPos = vec3(u_model * a_position); //Transform to world space\n    v_texCoord = a_texCoord;\n  }\n  ",fragment:"#version 300 es\n  precision mediump float;\n  uniform vec3 u_lightPos;\n  uniform vec3 u_cameraPos;\n  uniform vec3 u_lightColor;\n  uniform vec3 u_color;\n  uniform sampler2D u_sample;\n\n  in vec3 v_normal;\n  in vec3 v_fragPos;\n  in vec2 v_texCoord;\n  out vec4 outColor;\n  void main(){\n    vec3 normal = normalize(v_normal);\n    //calculate ambient light\n    vec3 ambientColor = 0.05 * u_lightColor * u_color;\n    vec3 diffColor = u_color;\n    //calculate diffuse light\n    vec3 lightDir = normalize(u_lightPos - v_fragPos);\n    float nDotL = max(dot(lightDir, normal), 0.0);\n    vec3 diffuseColor = diffColor * nDotL;\n    //calculate specular light\n    vec3 viewDir = normalize(u_cameraPos-v_fragPos);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(reflectDir, viewDir), 0.0), 64.0);\n    vec3 specularColor = u_lightColor * spec;\n    outColor = vec4(ambientColor + diffuseColor + specularColor , 1.0);\n  }\n  "},Sky:{vertex:"#version 300 es\n    precision mediump float;\n\n    in vec4 a_position;\n    in vec2 a_texCoord;\n    in vec3 a_normal;\n\n    out vec2 v_texCoord;\n    out vec3 v_normal;\n    out vec4 v_fragPos;\n\n    void main(){\n      v_fragPos = a_position;\n      v_fragPos.z = 1.0; // force z to be 1.0 for later transformation\n      v_normal = a_normal;\n      v_texCoord = a_texCoord;\n      gl_Position = a_position;\n      gl_Position.z = gl_Position.w;\n    }\n    ",fragment:"#version 300 es\n    #define SUN_COLOR vec3(0.6,0.5,0.2)\n    #define SUN_GLOW vec3(0.7,0.4,0.4)\n    #define SKY_COLOR vec3(0.5,0.6,0.9)\n    #define SUN_DIR vec3(0.0, 0.5, -1.0)\n\n    precision mediump float;\n    uniform sampler2D u_noisemap;\n    uniform float u_time;\n    uniform mat4 u_viewProjectInvMatrix;\n    in vec4 v_fragPos;\n    out vec4 outColor;\n\n    float noise(in vec2 uv) {\n        return texture(u_noisemap, uv/64.0).r;\n    }\n\n    float smoothNoise(in vec2 uv) {\n        vec2 luv = fract(uv); //range from 0.0 to 1.0\n        vec2 id = floor(uv); //the integer part of uv, 0, 1, 2\n        luv = luv*luv*(3.0 - 2.0*luv); //similar to smoothstep\n\n        //get values from the cordinates of a square\n        float bl = noise(id);\n        float br = noise(id + vec2(1.0, 0.0));\n        float tl = noise(id + vec2(0.0, 1.0));\n        float tr = noise(id + vec2(1.0, 1.0));\n\n        float b = mix(bl, br, luv.x); //interpolate between bl and br\n        float t = mix(tl, tr, luv.x); //interpolate between tl and tr\n\n        return mix(b, t, luv.y);\n    }\n\n    float fbm4(in vec2 uv) {\n        float amp = 0.5;\n        float f = 2.0;\n        float h = 0.0;\n        float a = 0.0;\n        for (int i = 0; i < 4; i++){\n            h += amp * smoothNoise(uv*f);\n            a += amp;\n            amp *= 0.5;\n            f *= 2.0;\n        }\n\n        h /= a;\n        return h;\n    }\n\n    vec3 calcSky(vec3 skyColor, vec3 cloudColor, vec2 uv) {\n        vec3 col = vec3(0.0);\n        // speed\n        float v = 0.001;\n        // layer1\n        vec2 scale = uv * 2.0;\n        vec2 turbulence = 0.008 * vec2(noise(vec2(uv.x * 10.0, uv.y *10.0)), noise(vec2(uv.x * 10.0, uv.y * 10.0)));\n        scale += turbulence;\n    \t  float n1 = fbm4(uv);\n\n        col = mix( skyColor, cloudColor, smoothstep(0.2, 0.8, n1));\n        col = min(col, vec3(1.0));\n        return col;\n    }\n\n    vec3 skybox() {\n      vec4 t = u_viewProjectInvMatrix * v_fragPos;\n      vec3 rd = normalize(t.xyz / t.w);\n      // A simple way to place some clouds on a distant plane above the terrain -- Based on something IQ uses.\n      const float SC = 1e5;\n      // Trace out to a distant XZ plane.\n      float dist = (SC - 0.0)/rd.y;\n      vec2 p = (dist*rd).xz;\n\n      vec3 sunDir = normalize(SUN_DIR);\n      float sun = max(dot(sunDir, rd),0.0);\n      vec3 skyCol = vec3(0.0);\n      vec3 cloudCol = vec3(1.0);\n\n      skyCol += mix(SUN_GLOW, SKY_COLOR, 2.0*abs(rd.y));//horizontal brightness\n      skyCol += 0.5*SUN_COLOR*pow(sun, 64.0);\n      skyCol += 0.4*SUN_GLOW*pow(sun, 32.0);\n\n      skyCol = calcSky(skyCol, cloudCol, p/SC);\n      float grad = smoothstep(0.0, 0.3, rd.y);\n      skyCol = mix(SUN_GLOW*vec3(0.4,0.6,0.6), skyCol, grad);\n\n      return skyCol;\n    }\n\n    void main(){\n      outColor = vec4(skybox(), 1.0);\n    }\n    "},PBR:{vertex:"#version 300 es\n#pragma vscode_glsllint_stage : vert\nprecision mediump float;\nuniform mat4 u_model;\nuniform mat4 u_view;\nuniform mat4 u_projection;\nuniform mat4 u_normalMatrix;\nuniform vec3 u_lightPos;\nuniform vec3 u_cameraPos;\nuniform sampler2D u_normal;\n\nin vec4 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec3 a_tangent;\n\nout vec2 v_texCoord; \nout vec3 v_normal; \nout vec3 v_fragPos;\nout vec3 v_tangentLightPos;\nout vec3 v_tangentCameraPos;\nout vec3 v_tangentFragPos; \n\nvoid main(){\n  gl_Position = u_projection * u_view * u_model * a_position;\n  vec3 T = normalize(vec3(u_model * vec4(a_tangent, 0.0)));\n  vec3 N = normalize(vec3(u_model * vec4(a_normal, 0.0)));\n  vec3 B = cross(N, T);\n  v_normal = mat3(u_normalMatrix) * a_normal; //Transform to world space\n  v_fragPos = vec3(u_model * a_position); //Transform to world space\n  v_texCoord = a_texCoord;\n  mat3 TBN = transpose(mat3(T, B, N));\n  v_tangentLightPos = TBN * u_lightPos;\n  v_tangentCameraPos = TBN * u_cameraPos;\n  v_tangentFragPos = TBN * v_fragPos;\n}\n",fragment:"#version 300 es\n#pragma vscode_glsllint_stage : frag\nprecision mediump float;\nuniform vec3 u_lightPos;\nuniform vec3 u_cameraPos;\nuniform vec3 u_lightColor;\nuniform vec3 u_specularColor;\nuniform sampler2D u_color;\nuniform sampler2D u_metallic;\nuniform sampler2D u_roughness;\nuniform sampler2D u_ao;\nuniform sampler2D u_emission;\nuniform sampler2D u_normal;\n\nin vec3 v_normal;\nin vec3 v_fragPos;\nin vec2 v_texCoord;\nin vec3 v_tangentLightPos;\nin vec3 v_tangentCameraPos;\nin vec3 v_tangentFragPos; \n\nout vec4 outColor;\n\n#define PI 3.1415926\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nfloat distributionGGX(vec3 N, vec3 H, float roughness) {\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH * NdotH;\n    \n    float num = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n    return num / denom;\n}\n\nfloat geometrySchlickGGX(float NdotV, float roughness) {\n    float r = (roughness + 1.0);\n    float k = r * r / 8.0;\n    float num = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n    return num / denom;\n}\n\nfloat geometrySmith(float NdotV, float NdotL, float roughness) {\n    float ggx2 = geometrySchlickGGX(NdotV, roughness);\n    float ggx1 = geometrySchlickGGX(NdotL, roughness);\n    return ggx1 * ggx2;\n}\n\n// v, l are not normalized\nvec3 calcLight(vec3 N, vec3 v, vec3 l, vec3 albedo) {\n    vec3 Lo = vec3(0.0);\n    vec3 F0 = vec3(0.04);\n    \n    float metallic = texture(u_metallic, v_texCoord).r;\n    float roughness = texture(u_roughness, v_texCoord).r;\n    F0 = mix(F0, albedo, metallic);\n    vec3 light = vec3(150.0, 150.0, 120.0);\n    //for (int i = 0; i < 4; ++i) \n    {   \n        vec3 V = normalize(v);\n        vec3 L = normalize(l);\n        vec3 H = normalize(V + L);\n        float cosTheta = max(dot(H, V), 0.0);\n        float NdotV = max(dot(N, V), 0.0);\n        float NdotL = max(dot(N, L), 0.0);\n        float dist = length(l);\n        float atten = 1.0 / (dist * dist);\n        vec3 radiance = light * atten;\n        vec3 F = fresnelSchlick(cosTheta, F0);\n        float NDF = distributionGGX(N, H, roughness);\n        float G = geometrySmith(NdotV, NdotL, roughness);\n        vec3 num = NDF * G * F;\n        float denom = 4.0 * NdotV * NdotL;\n        vec3 specular = num / max(denom, 0.001);\n\n        vec3 ks = F;\n        vec3 kd = 1.0 - ks;\n        kd *= 1.0 - metallic;\n\n        Lo += (kd * albedo / PI + specular) * radiance * NdotL;\n    }\n    return Lo;\n}\n\nvoid main(){\n    vec3 N = 2.0 * texture(u_normal, v_texCoord).rgb - 1.0;\n    vec3 viewPos = v_tangentCameraPos;\n    vec3 fragPos = v_tangentFragPos;\n    vec3 lightPos = v_tangentLightPos;\n    vec3 viewDir = viewPos - fragPos;\n    vec3 lightDir = lightPos - fragPos;\n\n    vec3 albedo = pow(texture(u_color, v_texCoord).rgb, vec3(2.2));\n    vec3 emission = texture(u_emission, v_texCoord).rgb;\n    vec3 ao = texture(u_ao, v_texCoord).rgb;\n    vec3 Lo = calcLight(N, viewDir, lightDir, albedo);\n    vec3 ambient = vec3(0.03) * albedo * ao;\n    vec3 col = Lo + ambient;\n    // HDR tonemapping\n    col = col / (col + vec3(1.0));\n    // gamma correct\n    col = pow(col, vec3(1.0/2.2)); \n    outColor = vec4(col, 1.0);\n}"}},"2D":{Blank:v,ZenTime:m,ThatCat:d,Nowhere:p,Mushroom:h,Halloween:g,GetOut:x,Water:y,Cloud:b,Cloud2D:_,Transparency:C,BigBang:A,Set:w,Glassy:E,Glow:S}},textures:{Blank:["stone"],ThatCat:["noise64"],Nowhere:["noise64"],Mushroom:["noise64","stone"],Halloween:["noise64"],Water:["noise64","stone"],Cloud:["noise64"],Glassy:["stone"]},cubemapTextures:{BigBang:["building"],Glassy:["forest"],Glow:["forest"]},currentShader:{"2D":"ZenTime","3D":"PBR"},lightInfo:{position:[-10,10,5],color:[1,1,.97]},cameraInfo:{position:[0,0,10],target:[0,0,0]},currentScene:"3D",currentModel:"case",model:{case:{modelType:"custom",path:P,model:null,text:"",transform:{translate:[0,-2,-5],rotateAxis:[0,1,0],rotateDegree:0,autoRotate:!1,scale:[.1,.1,.1]},textures:{normal:{path:L,img:null,desc:"Normal Map"},color:{path:k,img:null,desc:"Color"},metallic:{path:F,img:null,desc:"Metallic"},roughness:{path:M,img:null,desc:"Roughness"},ao:{path:O,img:null,desc:"AmbientOcclusion"},emission:{path:null,img:null,desc:"Emission"}}},cup:{modelType:"custom",path:N,model:null,text:"",transform:{translate:[0,-1,-2],rotateAxis:[0,1,0],rotateDegree:0,autoRotate:!1},textures:{normal:{path:U,img:null,desc:"Normal Map"},color:{path:z,img:null,desc:"Color"},metallic:{path:j,img:null,desc:"Metallic"},roughness:{path:B,img:null,desc:"Roughness"}}},cube:{modelType:"custom",path:X,model:X,text:"",transform:{translate:[0,-2,-5],rotateAxis:[0,1,0],rotateDegree:0,autoRotate:!1,scale:[1,1,1]},textures:{normal:{path:H,img:null,desc:"Normal Map"},color:{path:G,img:null,desc:"Color"},metallic:{path:j,img:null,desc:"Metallic"},roughness:{path:B,img:null,desc:"Roughness"},ao:{path:null,img:null,desc:"AmbientOcclusion"},emission:{path:null,img:null,desc:"Emission"}}}},images:{noise64:{path:T,img:null},noise256:{path:I,img:null},wood:{path:R,img:null},stone:{path:D,img:null}},cubemaps:{building:{right:{path:q,img:null},left:{path:V,img:null},top:{path:W,img:null},bottom:{path:Y,img:null},front:{path:Z,img:null},back:{path:K,img:null}},forest:{right:{path:$,img:null},left:{path:J,img:null},top:{path:Q,img:null},bottom:{path:nn,img:null},front:{path:en,img:null},back:{path:tn,img:null}}}},cn={get:function(){return Object.assign({},an)},getById:function(n){return Array.isArray(an[n])?l()(an[n]):"object"===c()(an[n])?Object.assign({},an[n]):an[n]},setDataById:function(n,e){an[n]=Object.assign({},rn(rn({},an[n]),e))}};Object.freeze(cn);const sn=cn;var ln=t(4575),un=t.n(ln),fn=t(3913),vn=t.n(fn);function mn(n){var e=document.getElementsByTagName("body")[0];if(e){var t=window.WebGLRenderingContext?'It doesn\'t appear your computer can support WebGL.<br/><a href="http://get.webgl.org">Click here for more information.</a>':'This page requires a browser that supports WebGL.<br/><a href="http://get.webgl.org">Click here to upgrade your browser.</a>';n&&(t+="<br/><br/>Status: ".concat(n)),e.innerHTML=function(n){return"".concat('<div style="margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;">').concat(n,"</div>")}(t)}}window.requestAnimationFrame||(window.requestAnimationFrame=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n){window.setTimeout(n,1e3/60)}),window.cancelAnimationFrame||(window.cancelAnimationFrame=window.cancelRequestAnimationFrame||window.webkitCancelAnimationFrame||window.webkitCancelRequestAnimationFrame||window.mozCancelAnimationFrame||window.mozCancelRequestAnimationFrame||window.msCancelAnimationFrame||window.msCancelRequestAnimationFrame||window.oCancelAnimationFrame||window.oCancelRequestAnimationFrame||window.clearTimeout);var dn=function(n,e,t){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=hn(n,e,t,o);return r||(console.log("Failed to create program"),null)},pn=function(n,e){n.useProgram(e),n.program=e},hn=function(n,e,t){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=gn(n,n.VERTEX_SHADER,e),i=gn(n,n.FRAGMENT_SHADER,t);if(!r||!i)return null;var a=n.createProgram();if(!a)return null;n.attachShader(a,r),n.attachShader(a,i),null!=o&&n.transformFeedbackVaryings(a,o,n.INTERLEAVED_ATTRIBS),n.linkProgram(a);var c=n.getProgramParameter(a,n.LINK_STATUS);if(!c){var s=n.getProgramInfoLog(a);return console.log("Failed to link program: ".concat(s)),n.deleteProgram(a),n.deleteShader(i),n.deleteShader(r),null}return a},gn=function(n,e,t){var o=n.createShader(e);if(null==o)return console.log("unable to create shader"),null;if(n.shaderSource(o,t),n.compileShader(o),!n.getShaderParameter(o,n.COMPILE_STATUS)){var r=n.getShaderInfoLog(o);return console.log("Failed to compile shader: ".concat(r)),n.deleteShader(o),null}return o};function xn(n,e,t,o){var r=n.getUniformLocation(n.program,o);if(!r)return console.log("Failed to get the storage location of "+o),!1;n.uniform1i(r,t),n.activeTexture(n.TEXTURE0+t),n.bindTexture(n.TEXTURE_2D,e)}function yn(n,e,t,o){var r=n.getUniformLocation(n.program,o);if(!r)return console.log("Failed to get the storage location of"+o),!1;n.uniform1i(r,t),n.activeTexture(n.TEXTURE0+t),n.bindTexture(n.TEXTURE_CUBE_MAP,e)}function bn(n,e,t,o,r,i){if(!e)return console.log("Failed to create the image object"),null;var a=n.createTexture();return a?(n.bindTexture(n.TEXTURE_2D,a),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,o||n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,t||n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,r||n.REPEAT),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,i||n.REPEAT),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,1),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e),a):(console.log("Failed to create the texture object"),null)}function Cn(n,e,t,o,r,i,a){if(!e||e.length<6)return null;var c=[["right",n.TEXTURE_CUBE_MAP_POSITIVE_X],["left",n.TEXTURE_CUBE_MAP_NEGATIVE_X],["top",n.TEXTURE_CUBE_MAP_POSITIVE_Y],["bottom",n.TEXTURE_CUBE_MAP_NEGATIVE_Y],["front",n.TEXTURE_CUBE_MAP_POSITIVE_Z],["back",n.TEXTURE_CUBE_MAP_NEGATIVE_Z]],s=n.createTexture();if(!s)return console.log("Failed to create the texture object"),null;n.bindTexture(n.TEXTURE_CUBE_MAP,s);for(var l=0;l<c.length;++l){var u=c[l][0],f=c[l][1],v=e[u].img;if(!v){console.log("Failed to create the image object");break}n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MIN_FILTER,o||n.LINEAR),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MAG_FILTER,t||n.LINEAR),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_S,r||n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_T,i||n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_R,a||n.CLAMP_TO_EDGE),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,0),n.texImage2D(f,0,n.RGB,n.RGB,n.UNSIGNED_BYTE,v)}return s}function _n(n,e,t,o,r,i,a,c,s,l,u){var f=n.createTexture();return f?(n.bindTexture(n.TEXTURE_2D,f),n.texImage2D(n.TEXTURE_2D,0,o,e,t,0,r,a,null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,s),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,c),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,l),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,u),n.bindTexture(n.TEXTURE_2D,null),f):(console.log("Failed to create the texture object"),!1)}function An(n,e,t,o,r,i,a,c,s,l,u,f){n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,r,t,o,0,i,c,null),n.bindTexture(n.TEXTURE_2D,null)}function wn(n,e){var t=n.createBuffer();return t?(n.bindBuffer(n.ARRAY_BUFFER,t),n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW),t):(console.log("Failed to create the buffer object"),-1)}function En(n,e){var t=n.createBuffer();return t?(n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t),n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW),t):(console.log("Failed to create the index buffer."),-1)}function Sn(n,e,t,o){var r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:n.FLOAT,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;if(!e)return console.log("Invalid buffer object!"),-1;n.bindBuffer(n.ARRAY_BUFFER,e);var c=n.getAttribLocation(n.program,o);return c<0?(console.log("Failed to get the storage location of "+o),-1):(n.enableVertexAttribArray(c),n.vertexAttribPointer(c,t,r,!1,i,a),c)}function Tn(n,e,t){var o=n.getUniformLocation(n.program,t);o<0?console.log("Failed to get the storage location of "+t):n.uniform1f(o,e)}function In(n,e,t){var o=n.getUniformLocation(n.program,t);o<0?console.log("Failed to get the storage location of "+t):n.uniform4f(o,e[0],e[1],e[2],e[3])}function Dn(n,e,t){var o=n.getUniformLocation(n.program,t);o<0?console.log("Failed to get the storage location of "+t):n.uniform3f(o,e[0],e[1],e[2])}function Rn(n,e,t){var o=n.getUniformLocation(n.program,t);o<0?console.log("Failed to get the storage location of "+t):n.uniform2f(o,e[0],e[1])}function Pn(n,e,t){var o=n.getUniformLocation(n.program,t);o<0?console.log("Failed to get the storage location of "+t):n.uniformMatrix4fv(o,!1,e.elements)}const On=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};un()(this,n);var t=e.uniforms,o=e.shaders;this.uniforms=t,this.shaderProgram=null,this.shaders=o,this.textureUnit={},this.textureUnitCount=0}return vn()(n,[{key:"setProgram",value:function(n){this.shaderProgram=n}},{key:"getTextureUnit",value:function(n){return n in this.textureUnit||(this.textureUnit[n]=this.textureUnitCount,this.textureUnitCount++),this.textureUnit[n]}}]),n}();var kn=t(2205),Fn=t.n(kn),Mn=t(8585),Ln=t.n(Mn),Nn=t(9754),zn=t.n(Nn),Un=function(n){var e,t,o;if(n&&"object"===c()(n)&&Object.prototype.hasOwnProperty.call(n,"elements")){for(t=n.elements,o=new Float32Array(16),e=0;e<16;++e)o[e]=t[e];this.elements=o}else this.elements=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])};Un.prototype.setIdentity=function(){var n=this.elements;return n[0]=1,n[4]=0,n[8]=0,n[12]=0,n[1]=0,n[5]=1,n[9]=0,n[13]=0,n[2]=0,n[6]=0,n[10]=1,n[14]=0,n[3]=0,n[7]=0,n[11]=0,n[15]=1,this},Un.prototype.set=function(n){var e,t,o;if((t=n.elements)!==(o=this.elements)){for(e=0;e<16;++e)o[e]=t[e];return this}},Un.prototype.concat=function(n){var e,t,o,r,i,a,c,s;if(t=this.elements,o=this.elements,t===(r=n.elements))for(r=new Float32Array(16),e=0;e<16;++e)r[e]=t[e];for(e=0;e<4;e++)i=o[e],a=o[e+4],c=o[e+8],s=o[e+12],t[e]=i*r[0]+a*r[1]+c*r[2]+s*r[3],t[e+4]=i*r[4]+a*r[5]+c*r[6]+s*r[7],t[e+8]=i*r[8]+a*r[9]+c*r[10]+s*r[11],t[e+12]=i*r[12]+a*r[13]+c*r[14]+s*r[15];return this},Un.prototype.multiply=Un.prototype.concat,Un.prototype.multiplyVector3=function(n){var e=this.elements,t=n.elements,o=new jn,r=o.elements;return r[0]=t[0]*e[0]+t[1]*e[4]+t[2]*e[8]+e[12],r[1]=t[0]*e[1]+t[1]*e[5]+t[2]*e[9]+e[13],r[2]=t[0]*e[2]+t[1]*e[6]+t[2]*e[10]+e[14],o},Un.prototype.multiplyVector4=function(n){var e=this.elements,t=n.elements,o=new Xn,r=o.elements;return r[0]=t[0]*e[0]+t[1]*e[4]+t[2]*e[8]+t[3]*e[12],r[1]=t[0]*e[1]+t[1]*e[5]+t[2]*e[9]+t[3]*e[13],r[2]=t[0]*e[2]+t[1]*e[6]+t[2]*e[10]+t[3]*e[14],r[3]=t[0]*e[3]+t[1]*e[7]+t[2]*e[11]+t[3]*e[15],o},Un.prototype.transpose=function(){var n,e;return e=(n=this.elements)[1],n[1]=n[4],n[4]=e,e=n[2],n[2]=n[8],n[8]=e,e=n[3],n[3]=n[12],n[12]=e,e=n[6],n[6]=n[9],n[9]=e,e=n[7],n[7]=n[13],n[13]=e,e=n[11],n[11]=n[14],n[14]=e,this},Un.prototype.setInverseOf=function(n){var e,t,o,r,i;if(t=n.elements,o=this.elements,(r=new Float32Array(16))[0]=t[5]*t[10]*t[15]-t[5]*t[11]*t[14]-t[9]*t[6]*t[15]+t[9]*t[7]*t[14]+t[13]*t[6]*t[11]-t[13]*t[7]*t[10],r[4]=-t[4]*t[10]*t[15]+t[4]*t[11]*t[14]+t[8]*t[6]*t[15]-t[8]*t[7]*t[14]-t[12]*t[6]*t[11]+t[12]*t[7]*t[10],r[8]=t[4]*t[9]*t[15]-t[4]*t[11]*t[13]-t[8]*t[5]*t[15]+t[8]*t[7]*t[13]+t[12]*t[5]*t[11]-t[12]*t[7]*t[9],r[12]=-t[4]*t[9]*t[14]+t[4]*t[10]*t[13]+t[8]*t[5]*t[14]-t[8]*t[6]*t[13]-t[12]*t[5]*t[10]+t[12]*t[6]*t[9],r[1]=-t[1]*t[10]*t[15]+t[1]*t[11]*t[14]+t[9]*t[2]*t[15]-t[9]*t[3]*t[14]-t[13]*t[2]*t[11]+t[13]*t[3]*t[10],r[5]=t[0]*t[10]*t[15]-t[0]*t[11]*t[14]-t[8]*t[2]*t[15]+t[8]*t[3]*t[14]+t[12]*t[2]*t[11]-t[12]*t[3]*t[10],r[9]=-t[0]*t[9]*t[15]+t[0]*t[11]*t[13]+t[8]*t[1]*t[15]-t[8]*t[3]*t[13]-t[12]*t[1]*t[11]+t[12]*t[3]*t[9],r[13]=t[0]*t[9]*t[14]-t[0]*t[10]*t[13]-t[8]*t[1]*t[14]+t[8]*t[2]*t[13]+t[12]*t[1]*t[10]-t[12]*t[2]*t[9],r[2]=t[1]*t[6]*t[15]-t[1]*t[7]*t[14]-t[5]*t[2]*t[15]+t[5]*t[3]*t[14]+t[13]*t[2]*t[7]-t[13]*t[3]*t[6],r[6]=-t[0]*t[6]*t[15]+t[0]*t[7]*t[14]+t[4]*t[2]*t[15]-t[4]*t[3]*t[14]-t[12]*t[2]*t[7]+t[12]*t[3]*t[6],r[10]=t[0]*t[5]*t[15]-t[0]*t[7]*t[13]-t[4]*t[1]*t[15]+t[4]*t[3]*t[13]+t[12]*t[1]*t[7]-t[12]*t[3]*t[5],r[14]=-t[0]*t[5]*t[14]+t[0]*t[6]*t[13]+t[4]*t[1]*t[14]-t[4]*t[2]*t[13]-t[12]*t[1]*t[6]+t[12]*t[2]*t[5],r[3]=-t[1]*t[6]*t[11]+t[1]*t[7]*t[10]+t[5]*t[2]*t[11]-t[5]*t[3]*t[10]-t[9]*t[2]*t[7]+t[9]*t[3]*t[6],r[7]=t[0]*t[6]*t[11]-t[0]*t[7]*t[10]-t[4]*t[2]*t[11]+t[4]*t[3]*t[10]+t[8]*t[2]*t[7]-t[8]*t[3]*t[6],r[11]=-t[0]*t[5]*t[11]+t[0]*t[7]*t[9]+t[4]*t[1]*t[11]-t[4]*t[3]*t[9]-t[8]*t[1]*t[7]+t[8]*t[3]*t[5],r[15]=t[0]*t[5]*t[10]-t[0]*t[6]*t[9]-t[4]*t[1]*t[10]+t[4]*t[2]*t[9]+t[8]*t[1]*t[6]-t[8]*t[2]*t[5],0==(i=t[0]*r[0]+t[1]*r[4]+t[2]*r[8]+t[3]*r[12]))return this;for(i=1/i,e=0;e<16;e++)o[e]=r[e]*i;return this},Un.prototype.invert=function(){return this.setInverseOf(this)},Un.prototype.setOrtho=function(n,e,t,o,r,i){var a,c,s,l;if(n===e||t===o||r===i)throw"null frustum";return c=1/(e-n),s=1/(o-t),l=1/(i-r),(a=this.elements)[0]=2*c,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=2*s,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=-2*l,a[11]=0,a[12]=-(e+n)*c,a[13]=-(o+t)*s,a[14]=-(i+r)*l,a[15]=1,this},Un.prototype.ortho=function(n,e,t,o,r,i){return this.concat((new Un).setOrtho(n,e,t,o,r,i))},Un.prototype.setFrustum=function(n,e,t,o,r,i){var a,c,s,l;if(n===e||o===t||r===i)throw"null frustum";if(r<=0)throw"near <= 0";if(i<=0)throw"far <= 0";return c=1/(e-n),s=1/(o-t),l=1/(i-r),(a=this.elements)[0]=2*r*c,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=2*r*s,a[6]=0,a[7]=0,a[8]=(e+n)*c,a[9]=(o+t)*s,a[10]=-(i+r)*l,a[11]=-1,a[12]=0,a[13]=0,a[14]=-2*r*i*l,a[15]=0,this},Un.prototype.frustum=function(n,e,t,o,r,i){return this.concat((new Un).setFrustum(n,e,t,o,r,i))},Un.prototype.setPerspective=function(n,e,t,o){var r,i,a,c;if(t===o||0===e)throw"null frustum";if(t<=0)throw"near <= 0";if(o<=0)throw"far <= 0";if(n=Math.PI*n/180/2,0===(a=Math.sin(n)))throw"null frustum";return i=1/(o-t),c=Math.cos(n)/a,(r=this.elements)[0]=c/e,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=c,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=-(o+t)*i,r[11]=-1,r[12]=0,r[13]=0,r[14]=-2*t*o*i,r[15]=0,this},Un.prototype.perspective=function(n,e,t,o){return this.concat((new Un).setPerspective(n,e,t,o))},Un.prototype.setScale=function(n,e,t){var o=this.elements;return o[0]=n,o[4]=0,o[8]=0,o[12]=0,o[1]=0,o[5]=e,o[9]=0,o[13]=0,o[2]=0,o[6]=0,o[10]=t,o[14]=0,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this},Un.prototype.scale=function(n,e,t){var o=this.elements;return o[0]*=n,o[4]*=e,o[8]*=t,o[1]*=n,o[5]*=e,o[9]*=t,o[2]*=n,o[6]*=e,o[10]*=t,o[3]*=n,o[7]*=e,o[11]*=t,this},Un.prototype.setTranslate=function(n,e,t){var o=this.elements;return o[0]=1,o[4]=0,o[8]=0,o[12]=n,o[1]=0,o[5]=1,o[9]=0,o[13]=e,o[2]=0,o[6]=0,o[10]=1,o[14]=t,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this},Un.prototype.translate=function(n,e,t){var o=this.elements;return o[12]+=o[0]*n+o[4]*e+o[8]*t,o[13]+=o[1]*n+o[5]*e+o[9]*t,o[14]+=o[2]*n+o[6]*e+o[10]*t,o[15]+=o[3]*n+o[7]*e+o[11]*t,this},Un.prototype.setRotate=function(n,e,t,o){var r,i,a,c,s,l,u,f,v,m,d,p;return n=Math.PI*n/180,r=this.elements,i=Math.sin(n),a=Math.cos(n),0!==e&&0===t&&0===o?(e<0&&(i=-i),r[0]=1,r[4]=0,r[8]=0,r[12]=0,r[1]=0,r[5]=a,r[9]=-i,r[13]=0,r[2]=0,r[6]=i,r[10]=a,r[14]=0,r[3]=0,r[7]=0,r[11]=0,r[15]=1):0===e&&0!==t&&0===o?(t<0&&(i=-i),r[0]=a,r[4]=0,r[8]=i,r[12]=0,r[1]=0,r[5]=1,r[9]=0,r[13]=0,r[2]=-i,r[6]=0,r[10]=a,r[14]=0,r[3]=0,r[7]=0,r[11]=0,r[15]=1):0===e&&0===t&&0!==o?(o<0&&(i=-i),r[0]=a,r[4]=-i,r[8]=0,r[12]=0,r[1]=i,r[5]=a,r[9]=0,r[13]=0,r[2]=0,r[6]=0,r[10]=1,r[14]=0,r[3]=0,r[7]=0,r[11]=0,r[15]=1):(1!==(c=Math.sqrt(e*e+t*t+o*o))&&(e*=s=1/c,t*=s,o*=s),l=1-a,u=e*t,f=t*o,v=o*e,m=e*i,d=t*i,p=o*i,r[0]=e*e*l+a,r[1]=u*l+p,r[2]=v*l-d,r[3]=0,r[4]=u*l-p,r[5]=t*t*l+a,r[6]=f*l+m,r[7]=0,r[8]=v*l+d,r[9]=f*l-m,r[10]=o*o*l+a,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1),this},Un.prototype.rotate=function(n,e,t,o){return this.concat((new Un).setRotate(n,e,t,o))},Un.prototype.setLookAt=function(n,e,t,o,r,i,a,c,s){var l,u,f,v,m,d,p,h,g,x,y,b;return u=o-n,f=r-e,v=i-t,d=(f*=m=1/Math.sqrt(u*u+f*f+v*v))*s-(v*=m)*c,p=v*a-(u*=m)*s,h=u*c-f*a,x=(p*=g=1/Math.sqrt(d*d+p*p+h*h))*v-(h*=g)*f,y=h*u-(d*=g)*v,b=d*f-p*u,(l=this.elements)[0]=d,l[1]=x,l[2]=-u,l[3]=0,l[4]=p,l[5]=y,l[6]=-f,l[7]=0,l[8]=h,l[9]=b,l[10]=-v,l[11]=0,l[12]=0,l[13]=0,l[14]=0,l[15]=1,this.translate(-n,-e,-t)},Un.prototype.lookAt=function(n,e,t,o,r,i,a,c,s){return this.concat((new Un).setLookAt(n,e,t,o,r,i,a,c,s))},Un.prototype.dropShadow=function(n,e){var t=new Un,o=t.elements,r=n[0]*e[0]+n[1]*e[1]+n[2]*e[2]+n[3]*e[3];return o[0]=r-e[0]*n[0],o[1]=-e[1]*n[0],o[2]=-e[2]*n[0],o[3]=-e[3]*n[0],o[4]=-e[0]*n[1],o[5]=r-e[1]*n[1],o[6]=-e[2]*n[1],o[7]=-e[3]*n[1],o[8]=-e[0]*n[2],o[9]=-e[1]*n[2],o[10]=r-e[2]*n[2],o[11]=-e[3]*n[2],o[12]=-e[0]*n[3],o[13]=-e[1]*n[3],o[14]=-e[2]*n[3],o[15]=r-e[3]*n[3],this.concat(t)},Un.prototype.dropShadowDirectionally=function(n,e,t,o,r,i,a,c,s){var l=o*n+r*e+i*t;return this.dropShadow([n,e,t,-l],[a,c,s,0])};var Bn=function(n){var e=new Float32Array(2);n&&"object"===c()(n)&&(e[0]=n[0],e[1]=n[1]),this.elements=e};Bn.prototype.normalize=function(){var n=this.elements,e=n[0],t=n[1],o=Math.sqrt(e*e+t*t);return o?(1==o||(o=1/o,n[0]=e*o,n[1]=t*o),this):(n[0]=0,n[1]=0,this)},Bn.prototype.length=function(){var n=this.elements;return Math.sqrt(Math.pow(n[0],2)+Math.pow(n[1],2))};var jn=function(n){var e=new Float32Array(3);n&&"object"===c()(n)&&(e[0]=n[0],e[1]=n[1],e[2]=n[2]),this.elements=e};jn.prototype.normalize=function(){var n=this.elements,e=n[0],t=n[1],o=n[2],r=Math.sqrt(e*e+t*t+o*o);return r?(1==r||(r=1/r,n[0]=e*r,n[1]=t*r,n[2]=o*r),this):(n[0]=0,n[1]=0,n[2]=0,this)},jn.prototype.length=function(){var n=this.elements;return Math.sqrt(Math.pow(n[0],2)+Math.pow(n[1],2)+Math.pow(n[2],2))};var Xn=function(n){var e=new Float32Array(4);n&&"object"===c()(n)&&(e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3]),this.elements=e},Gn=function(n){return n.elements.length!=this.elements.length?null:this.elements.map((function(e,t){return e-n.elements[t]}))},Hn=function(n){return n.elements.length!=this.elements.length?null:this.elements.map((function(e,t){return e+n.elements[t]}))},qn=function(n){return this.elements.map((function(e){return e*n}))};Bn.prototype.subtract=function(n){var e=Gn.call(this,n);return new Bn(e)},jn.prototype.subtract=function(n){var e=Gn.call(this,n);return new jn(e)},Xn.prototype.subtract=function(n){var e=Gn.call(this,n);return new Xn(e)},Bn.prototype.add=function(n){var e=Hn.call(this,n);return new Bn(e)},jn.prototype.add=function(n){var e=Hn.call(this,n);return new jn(e)},Xn.prototype.add=function(n){var e=Hn.call(this,n);return new Xn(e)},Bn.prototype.scale=function(n){var e=qn.call(this,n);return new Bn(e)},jn.prototype.scale=function(n){var e=qn.call(this,n);return new jn(e)},Xn.prototype.scale=function(n){var e=qn.call(this,n);return new Xn(e)};const Vn=Un,Wn=function(){function n(){un()(this,n),this.vertices=[],this.normals=[],this.UVs=[],this.indices=[],this.tangents=[],this.modelMatrix=new Vn,this.normalMatrix=new Vn,this.buffer={},this.attributes={},this.translateValue=[0,0,0],this.scaleValue=[1,1,1],this.rotation=0,this.rotationAxis=[0,0,1],this.autoRotate=!1,this.angle=0,this.visible=!0,this.material=null,this.now=performance.now()}return vn()(n,[{key:"addMaterial",value:function(n){this.material=n}},{key:"setBuffer",value:function(n,e,t){this.buffer[n]={buffer:e,dataCount:t,binded:!0}}},{key:"addAttributes",value:function(n,e,t){var o={};o.value=e,o.elements=t,this.attributes[n]=o}},{key:"translate",value:function(n){this.translateValue=n}},{key:"scale",value:function(n){this.scaleValue=n}},{key:"rotate",value:function(n,e){this.rotation=n,this.rotationAxis=e}},{key:"updateAnimation",value:function(){if(this.modelMatrix.setTranslate(this.translateValue[0],this.translateValue[1],this.translateValue[2]),this.modelMatrix.scale(this.scaleValue[0],this.scaleValue[1],this.scaleValue[2]),this.autoRotate){var n=performance.now()-this.now;this.now=performance.now(),this.angle+=10*n/1e3,this.angle%=360,this.modelMatrix.rotate(this.angle,this.rotationAxis[0],this.rotationAxis[1],this.rotationAxis[2])}else this.modelMatrix.rotate(this.rotation,this.rotationAxis[0],this.rotationAxis[1],this.rotationAxis[2]);this.normalMatrix.setInverseOf(this.modelMatrix),this.normalMatrix.transpose()}}]),n}();const Yn=function(n){Fn()(r,n);var e,t,o=(e=r,t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(n){return!1}}(),function(){var n,o=zn()(e);if(t){var r=zn()(this).constructor;n=Reflect.construct(o,arguments,r)}else n=o.apply(this,arguments);return Ln()(this,n)});function r(){var n;return un()(this,r),(n=o.call(this)).generateSquareVertices(),n}return vn()(r,[{key:"generateSquareVertices",value:function(){this.vertices=[-1,-1,0,1,-1,0,1,1,0,1,1,0,-1,1,0,-1,-1,0],this.UVs=[0,0,1,0,1,1,1,1,0,1,0,0],this.normals=[0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1]}}]),r}(Wn),Zn=function(){function n(e){return un()(this,n),this.divId=e,this.gl=null,this.shaderProgram={},this.models={},this.framebuffer={},this.scene=null,this.camera=null,this.final=null,this.multiPassEnabled=!1,this.frameBufferTexture={},this.fogNear=.1,this.fogFar=20,this.fogAmount=.5,this.fogColor=[255,255,255],this.isMousedown=!1,this.lastMouse=[0,0],this.deltaMouse=[0,0],this.mousePos=[0,0],this.domElement=document.getElementById(e),this.domElement?(this.gl=function(n,e,t){var o=t||mn;n.addEventListener&&n.addEventListener("webglcontextcreationerror",(function(n){o(n.statusMessage)}),!1);var r=function(n,e){for(var t=["webgl2","experimental-webgl","webkit-3d","moz-webgl"],o=null,r=0;r<t.length;r+=1){try{o=n.getContext(t[r],e)}catch(n){console.log(n)}if(o)break}return o}(n,e);return r||(window.WebGLRenderingContext,o("")),r}(this.domElement)||null,this.gl?(this._initFramebuffers(),void this._initEventHandelers()):(console.log("Failed to get the webgl context"),!1)):(console.log("Fail to retrieve canvas element"),!1)}return vn()(n,[{key:"init",value:function(n,e){this.scene=n,this.camera=e,this._initWebGLContext(),this._createTextures(),this._compileShaders(),this._createFinalSquad(),this._createBufferData(),this.resizeCanvas()}},{key:"setFog",value:function(n,e,t,o){this.fogNear=n,this.fogFar=e,this.fogAmount=t,this.fogColor=o}},{key:"resizeCanvas",value:function(){var n=this.gl,e=window.devicePixelRatio,t=Math.floor(n.canvas.clientWidth*e),o=Math.floor(n.canvas.clientHeight*e);n.canvas.width==t&&n.canvas.height==o||(n.canvas.width=t,n.canvas.height=o),n.viewport(0,0,n.canvas.width,n.canvas.height),this.camera&&this.camera.setAspectRatio(n.canvas.clientWidth/n.canvas.clientHeight),this._updateRenderTexture()}},{key:"setMultiPass",value:function(n){this.multiPassEnabled=n}},{key:"render",value:function(){var n=this,e=this.gl;this.scene.updateAnimation(),this.camera.updateAnimation(),this.multiPassEnabled?e.bindFramebuffer(e.FRAMEBUFFER,this.framebuffer.first):e.bindFramebuffer(e.FRAMEBUFFER,null),e.viewport(0,0,e.canvas.width,e.canvas.height),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT),this.scene.geometries.forEach((function(e){n._renderObject(e)})),e.flush(),this.scene.skybox&&(e.disable(e.CULL_FACE),e.depthFunc(e.LEQUAL),this._renderObject(this.scene.skybox),e.depthFunc(e.LESS),e.enable(e.CULL_FACE)),this.multiPassEnabled&&(e.bindFramebuffer(e.FRAMEBUFFER,null),e.viewport(0,0,e.canvas.width,e.canvas.height),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT),this._renderObject(this.final))}},{key:"_initWebGLContext",value:function(){var n=this.gl;n.viewport(0,0,n.canvas.width,n.canvas.height),n.clearColor(.5,.5,.5,1),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),n.enable(n.DEPTH_TEST),n.enable(n.CULL_FACE),n.frontFace(n.CCW)}},{key:"_initFramebuffers",value:function(){var n=this.gl,e=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,e),this.framebuffer.first=e;var t=_n(n,n.canvas.width,n.canvas.height,n.RGBA,n.RGBA,0,n.UNSIGNED_BYTE,n.NEAREST,n.NEAREST,n.CLAMP_TO_EDGE,n.CLAMP_TO_EDGE),o=_n(n,n.canvas.width,n.canvas.height,n.DEPTH_COMPONENT24,n.DEPTH_COMPONENT,0,n.UNSIGNED_INT,n.NEAREST,n.NEAREST,n.CLAMP_TO_EDGE,n.CLAMP_TO_EDGE);this.frameBufferTexture.color=t,this.frameBufferTexture.depth=o,n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0),n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,o,0),n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null)}},{key:"_updateRenderTexture",value:function(){var n=this.gl;"color"in this.frameBufferTexture&&An(n,this.frameBufferTexture.color,n.canvas.width,n.canvas.height,n.RGBA,n.RGBA,0,n.UNSIGNED_BYTE,n.NEAREST,n.NEAREST,n.CLAMP_TO_EDGE,n.CLAMP_TO_EDGE),"depth"in this.frameBufferTexture&&An(n,this.frameBufferTexture.depth,n.canvas.width,n.canvas.height,n.DEPTH_COMPONENT24,n.DEPTH_COMPONENT,0,n.UNSIGNED_INT,n.NEAREST,n.NEAREST,n.CLAMP_TO_EDGE,n.CLAMP_TO_EDGE)}},{key:"_initEventHandelers",value:function(){var n=this,e=this.domElement;e.onmouseup=function(e){n.isMousedown=!1},e.onmousedown=function(e){n.isMousedown=!0,n._handleMouseClick(e)},e.onmousemove=function(t){if(n.isMousedown)n._handleMouseClick(t);else{var o=t.clientX,r=t.clientY,i=t.target.getBoundingClientRect();o=2*(o-i.left)/e.width-1,r=-2*(r-i.top)/e.height+1,n.lastMouse=[o,r]}},document.addEventListener("keydown",(function(e){if(n.camera)if("w"==e.key)n.camera.move("forward");else if("s"==e.key)n.camera.move("backward");else if("a"==e.key)n.camera.move("right");else if("d"==e.key)n.camera.move("left");else if("i"==e.key)n.camera.rotate("up");else if("k"==e.key)n.camera.rotate("down");else if("j"==e.key)n.camera.rotate("left");else{if("l"!=e.key)return;n.camera.rotate("right")}}))}},{key:"_handleMouseClick",value:function(n){var e=this.domElement,t=n.clientX,o=n.clientY,r=n.target.getBoundingClientRect();t=2*(t-r.left)/e.width-1,o=-2*(o-r.top)/e.height+1;var i=[];i[0]=t-this.lastMouse[0],i[1]=o-this.lastMouse[1],this.lastMouse=[t,o],this.mousePos=[n.clientX,r.height-n.clientY],this.camera.rotateWithMouse(i[0],i[1])}},{key:"_createBufferData",value:function(){var n=this;if(this.scene.geometries.forEach((function(e){pn(n.gl,e.material.shaderProgram),e.setBuffer("Vertices",wn(n.gl,new Float32Array(e.vertices)),3),e.setBuffer("UVs",wn(n.gl,new Float32Array(e.UVs)),2),e.setBuffer("Normals",wn(n.gl,new Float32Array(e.normals)),3),e.indices.length>0&&e.setBuffer("Indices",En(n.gl,new Uint16Array(e.indices)),3),e.tangents.length>0&&e.setBuffer("Tangents",wn(n.gl,new Float32Array(e.tangents)),3)})),this.scene.skybox){var e=this.scene.skybox;pn(this.gl,e.material.shaderProgram),e.setBuffer("Vertices",wn(this.gl,new Float32Array(e.vertices)),3),e.setBuffer("UVs",wn(this.gl,new Float32Array(e.UVs)),2),e.setBuffer("Normals",wn(this.gl,new Float32Array(e.normals)),3)}}},{key:"_compileShaders",value:function(){var n=this;if(this.scene.geometries.forEach((function(e){var t=e.material.shaders,o=t.vertex,r=t.fragment;e.material.shaderProgram=dn(n.gl,o,r)})),this.scene.skybox){var e=this.scene.skybox,t=e.material.shaders,o=t.vertex,r=t.fragment;e.material.shaderProgram=dn(this.gl,o,r)}}},{key:"_createTextures",value:function(){var n=this;if(this.scene.geometries.forEach((function(e){var t=e.material.uniforms;n._assignTextureObj(t)})),this.scene.skybox){var e=this.scene.skybox.material.uniforms;this._assignTextureObj(e)}}},{key:"_assignTextureObj",value:function(n){for(var e in n){var t=n[e],o=t.type,r=t.value;if(r&&"object"===c()(r))if("texture"===o){var i=r.image,a=r.properties,s=a.minParam,l=a.magParam,u=a.wrapSParam,f=a.wrapTParam;r.textureObj=bn(this.gl,i,this.gl[s],this.gl[l],this.gl[u],this.gl[f])}else if("cubemap"===o){var v=r.image,m=r.properties,d=m.minParam,p=m.magParam,h=m.wrapSParam,g=m.wrapTParam,x=m.wrapRParam;r.textureObj=Cn(this.gl,v,this.gl[d],this.gl[p],this.gl[h],this.gl[g],this.gl[x])}}}},{key:"_createFinalSquad",value:function(){var n=new Yn,e={u_near:{type:"f",value:this.fogNear},u_far:{type:"f",value:this.fogFar},u_fog:{type:"f",value:this.fogAmount},u_fogColor:{type:"v3",value:this.fogColor},u_sample:{type:"texture",value:{textureObj:this.frameBufferTexture.color}},u_depth:{type:"texture",value:{textureObj:this.frameBufferTexture.depth}}},t=new On({uniforms:e,shaders:u});n.addMaterial(t),this.final=n;var o=u.vertex,r=u.fragment;n.material.shaderProgram=dn(this.gl,o,r),n.setBuffer("Vertices",wn(this.gl,new Float32Array(n.vertices)),3),n.setBuffer("UVs",wn(this.gl,new Float32Array(n.UVs)),2),n.setBuffer("Normals",wn(this.gl,new Float32Array(n.normals)),3),n.indices.length>0&&n.setBuffer("Indices",En(this.gl,new Float32Array(n.indices)),3)}},{key:"_sendMaterialUniforms",value:function(n){var e,t,o,r,i=n.uniforms;for(var a in i){var c=a,s="f",l=i[a].value;if("type"in i[a]&&(s=i[a].type),"f"===s)Tn(this.gl,l,c);else if("t"===s)Tn(this.gl,performance.now()/1e3,c);else if("int"===s)t=l,o=c,void 0,(r=(e=this.gl).getUniformLocation(e.program,o))<0?console.log("Failed to get the storage location of "+o):e.uniform1ui(r,t);else if("texture"===s)xn(this.gl,l.textureObj,n.getTextureUnit(c),c);else if("cubemap"===s)yn(this.gl,l.textureObj,n.getTextureUnit(c),c);else if("v2"===s)Rn(this.gl,l,c);else if("v3"===s)Dn(this.gl,l,c);else if("v4"===s)In(this.gl,l,c);else if("mat4"===s)Pn(this.gl,l,c);else if("mouse"===s)Rn(this.gl,this.mousePos,c);else if("resolution"===s){var u=[this.gl.canvas.clientWidth,this.gl.canvas.clientHeight];Rn(this.gl,u,c)}}}},{key:"_sendCameraUniforms",value:function(){if(this.camera){var n=this.camera,e=n.viewMatrix,t=n.projectionMatrix,o=n.position,r=n.viewProjectionInvMatrix;Pn(this.gl,e,"u_view"),Pn(this.gl,t,"u_projection"),Dn(this.gl,o,"u_cameraPos"),this.scene.skybox&&Pn(this.gl,r,"u_viewProjectInvMatrix")}else console.log("No camera is found.")}},{key:"_sendLightUniforms",value:function(){if(this.scene.light){var n=this.scene.light,e=n.position,t=n.color,o=n.specularColor;Dn(this.gl,e,"u_lightPos"),Dn(this.gl,t,"u_lightColor"),Dn(this.gl,o,"u_specularColor")}}},{key:"_renderObject",value:function(n){var e,t,o=n.material,r=n.vertices,i=n.normals,a=n.indices,c=n.UVs,s=n.buffer,l=n.tangents;pn(this.gl,o.shaderProgram),r.length>0&&Sn(this.gl,s.Vertices.buffer,s.Vertices.dataCount,"a_position"),i.length>0&&Sn(this.gl,s.Normals.buffer,s.Normals.dataCount,"a_normal"),c.length>0&&Sn(this.gl,s.UVs.buffer,s.UVs.dataCount,"a_texCoord"),l.length>0&&Sn(this.gl,s.Tangents.buffer,s.Tangents.dataCount,"a_tangent"),this._sendMaterialUniforms(o),this._sendCameraUniforms(),this._sendLightUniforms(),a.length>0?(e=this.gl,t=a.length,e.drawElements(e.TRIANGLES,t,e.UNSIGNED_SHORT,0)):function(n,e){n.drawArrays(n.TRIANGLES,0,e)}(this.gl,r.length/3)}}]),n}(),Kn=function(){function n(){un()(this,n),this.element=null}return vn()(n,[{key:"getElement",value:function(){return this.element}}]),n}();const $n=function(n){Fn()(r,n);var e,t,o=(e=r,t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(n){return!1}}(),function(){var n,o=zn()(e);if(t){var r=zn()(this).constructor;n=Reflect.construct(o,arguments,r)}else n=o.apply(this,arguments);return Ln()(this,n)});function r(n){var e;un()(this,r),e=o.call(this);var t=document.createElement("div");return t.id=n,t.className="side-bar-right",e.element=t,e}return r}(Kn);const Jn=function(n){Fn()(r,n);var e,t,o=(e=r,t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(n){return!1}}(),function(){var n,o=zn()(e);if(t){var r=zn()(this).constructor;n=Reflect.construct(o,arguments,r)}else n=o.apply(this,arguments);return Ln()(this,n)});function r(n,e,t){var i;un()(this,r),(i=o.call(this)).id=n,i.textAreaId="textarea-".concat(n),i.submitId="submit-".concat(n);var a=document.createElement("div");return a.setAttribute("id","editor-".concat(n)),a.setAttribute("class","text-editor"),a.innerHTML='\n            <form class="black-80">\n                <div content-editable>\n                    <textarea id='.concat(i.textAreaId,' name="').concat(n,'" class="textbox lh-copy db border-box hover-white w-100 ba pa2 br2 mb2 f6" aria-describedby="').concat(e,'-desc">\n                        ').concat(t,"\n                    </textarea>\n                </div>\n            </form>\n            <a id=").concat(i.submitId,' class="f7 link dim br1 ph3 pv2 mb2 mt2 dib white bg-dark-green" href="#">Update</>\n        '),i.element=a,i}return vn()(r,[{key:"getTextAreaId",value:function(){return this.textAreaId}},{key:"getSubmitId",value:function(){return this.submitId}},{key:"bindEvent",value:function(n,e,t){var o="";switch(n){case"textarea":o=this.textAreaId;break;case"submit":o=this.submitId;break;default:console.log("Invalid target"),o=""}var r=document.getElementById(o);r&&r.addEventListener(e,(function(n){t(n)}))}}]),r}(Kn);const Qn=function(n){Fn()(r,n);var e,t,o=(e=r,t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(n){return!1}}(),function(){var n,o=zn()(e);if(t){var r=zn()(this).constructor;n=Reflect.construct(o,arguments,r)}else n=o.apply(this,arguments);return Ln()(this,n)});function r(){var n;return un()(this,r),(n=o.call(this)).element=document.createElement("div"),n.element.setAttribute("class","tabs"),n.checkboxId=0,n}return vn()(r,[{key:"addItem",value:function(n){var e=n.name,t=n.item,o=document.createElement("div");o.setAttribute("class","tab");var r=document.createElement("input");r.setAttribute("type","checkbox"),r.setAttribute("class","tab-input");var i=this._registerCheckboxId();r.setAttribute("id",i);var a=document.createElement("label");a.setAttribute("class","tab-label f6"),a.setAttribute("for",i),a.innerHTML=e;var c=document.createElement("div");c.setAttribute("class","tab-content"),c.appendChild(t),o.appendChild(r),o.appendChild(a),o.appendChild(c),this.element.appendChild(o)}},{key:"_registerCheckboxId",value:function(){var n=this.checkboxId;return this.checkboxId++,"check-".concat(n)}}]),r}(Kn);const ne=function(n){Fn()(r,n);var e,t,o=(e=r,t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(n){return!1}}(),function(){var n,o=zn()(e);if(t){var r=zn()(this).constructor;n=Reflect.construct(o,arguments,r)}else n=o.apply(this,arguments);return Ln()(this,n)});function r(n,e){var t,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"*",a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";un()(this,r),t=o.call(this);var c=document.createElement("div");c.id=n,c.innerHTML='\n            <label for="btn-'.concat(n,'" class="f7 mr2 white">').concat(e,'</label>\n            <a \n                id="btn-').concat(n,'" \n                onclick=document.getElementById("input-').concat(n,'").click()\n                class="f7 link dim br2 ph2 pv1 mb1 mt1 dib white bg-mid-gray"\n                style="cursor:pointer"\n            >\n                <i class="fas fa-file-upload"></i>\n            </a>\n            <input id="input-').concat(n,'" type="file" accept="').concat(i,'" name="model" style="display:none"></input>\n        ');var s=document.createElement("span");return s.id="filename",s.className="f7",s.innerText=a,c.appendChild(s),t.id=n,t.element=c,t.fileName=s,t}return vn()(r,[{key:"bindEvent",value:function(){var n=this,e=arguments.length>1?arguments[1]:void 0,t=arguments.length>2?arguments[2]:void 0,o=this.element.querySelector("input");o&&o.addEventListener(e,(function(e){e.stopPropagation(),e.preventDefault();var o=e.target.files[0];n.fileName.innerText=o.name,t(o)}))}}]),r}(Kn);const ee=function(n){Fn()(r,n);var e,t,o=(e=r,t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(n){return!1}}(),function(){var n,o=zn()(e);if(t){var r=zn()(this).constructor;n=Reflect.construct(o,arguments,r)}else n=o.apply(this,arguments);return Ln()(this,n)});function r(n,e,t){var i,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;un()(this,r),i=o.call(this);var c=document.createElement("div");c.id=n;var s=document.createElement("label");s.setAttribute("for","selector-".concat(n)),s.setAttribute("class","white mr2 f7"),s.innerText=e,c.appendChild(s);var l=document.createElement("select");return l.id="selector-".concat(n),l.className="f7 link dim br2 ph2 pv1 mb1 mt1 dib white bg-mid-gray",t.forEach((function(n){var e=document.createElement("option");e.value=n.toLowerCase(),e.innerText=n,l.appendChild(e)})),a&&(l.value=a.toLowerCase()),c.appendChild(l),i.element=c,i}return r}(Kn);const te=function(n){Fn()(r,n);var e,t,o=(e=r,t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(n){return!1}}(),function(){var n,o=zn()(e);if(t){var r=zn()(this).constructor;n=Reflect.construct(o,arguments,r)}else n=o.apply(this,arguments);return Ln()(this,n)});function r(n,e){var t,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;un()(this,r),t=o.call(this);var a=document.createElement("div");a.id=n;var c=document.createElement("select");return c.id="selector-".concat(n),c.className="f7 link dim br2 ph2 pv1 mb2 dib white bg-mid-gray",e.forEach((function(n){var e=document.createElement("option"),t=n.title;e.value=t.toLowerCase(),e.innerText=t,c.appendChild(e)})),i&&(c.value=i.toLowerCase()),a.appendChild(c),e.forEach((function(n){var e=i===n.title;a.appendChild(t._createContent(n,e)),e=!1})),c.addEventListener("change",(function(n){var e=document.getElementById(c.id);e&&a.querySelectorAll(".tab-content-wrapper").forEach((function(n){n.id==="content-".concat(e.value)?n.style.display="block":n.style.display="none"}))})),t.element=a,t}return vn()(r,[{key:"_createContent",value:function(n,e){var t=document.createElement("div");return t.id="content-".concat(n.title.toLowerCase()),t.className="tab-content-wrapper",t.style.display=e?"block":"none",t.appendChild(n.content),t}}]),r}(Kn);var oe=function(n){var e=document.getElementById(n);return e.options[e.selectedIndex].text},re=function(n,e){var t=document.createElement("li");return t.className="pv1 ba bl-0 bt-0 br-0 b--dotted b--white-30",t.appendChild(e),n.appendChild(t),t},ie=function(n){var e="";return""!==n&&(e=n.substring(n.lastIndexOf("/")+1)),e},ae=function(n,e,t,o){var r=new FileReader,i=new Image;r.onload=function(t){i.src=t.target.result,o(n,e,i)},r.readAsDataURL(t)},ce=function(n,e,t,o){var r=new FileReader;r.onload=function(t){o(n,e,t.target.result)},r.readAsText(t)},se=function(n,e,t){var o=n.getById("model");o[n.getById("currentModel")].textures[e].img=t,n.setDataById("model",o)},le=function(n,e,t){var o=n.getById("model");o[n.getById("currentModel")][e]=t,n.setDataById("model",o)},ue=function(n){var e=n.getById("currentScene"),t=document.createElement("div");t.setAttribute("id","model-editor");var o=new ee("scene","Select a scene",["3D","2D"],e);t.appendChild(o.getElement());var r=document.createElement("div");r.className="divider",t.appendChild(r);var i=function(n){var e=document.createElement("div");e.id="model-loader";var t=document.createElement("ul");t.className="list pl0 measure center mt1 mb1",e.appendChild(t);var o=n.get(),r=o.currentModel,i=o.model[r],a=i.path,c=i.textures,s=new ne("model","Model(.obj)",".obj",ie(a));s.bindEvent(null,"change",(function(e){ce(n,"text",e,le)})),re(t,s.getElement()),Object.keys(c).forEach((function(e){var o=c[e],r=new ne(e,o.desc,"image/*",function(n){var e="";if(n){var t=n.src;e=ie(t)}return e}(o.img));r.bindEvent(null,"change",(function(t){ae(n,e,t,se)})),re(t,r.getElement())}));var l=document.createElement("a");return l.id="model-editor-submit",l.className="f7 link dim br1 ph3 pv2 mb2 mt2 dib white bg-dark-green cursor-pointer",l.innerText="Update",e.appendChild(l),e}(n);return"2D"===e&&(i.style.display="none"),t.appendChild(i),t};const fe=function(n){var e={SUBMIT_SHADER:[],SELECT_SCENE:[],UPDATE_MODEL:[],SELECT_SHADER_2D:[],SELECT_SHADER_3D:[]},t=document.createElement("div");t.setAttribute("id","ui-root"),document.body.appendChild(t);var o=new $n("main-panel"),r=ue(n),i=function(n){var e=n.get(),t=e.shaders,o=e.currentShader,r=e.currentScene,i=document.createElement("div");return i.setAttribute("id","shader-editor-wrapper"),Object.keys(t).forEach((function(n){var e=n.toLowerCase(),a=document.createElement("div");a.id="editor-".concat(e);var c=t[n],s=[],l=o[n];Object.keys(c).forEach((function(n){var e=c[n].fragment,t=new Jn(n,n,e);s.push({title:n,content:t.getElement()})}));var u=new te("shader-editor-".concat(e),s,l);a.appendChild(u.getElement()),n!==r&&(a.style.display="none"),i.appendChild(a)})),i}(n),a=new Qn;return a.addItem({name:"Settings",item:r}),a.addItem({name:"Shaders",item:i}),o.getElement().appendChild(a.getElement()),t.appendChild(o.getElement()),i.querySelectorAll("textarea").forEach((function(n){n.addEventListener("keyup",(function(n){n.target&&sessionStorage.setItem(n.target.id,n.target.value)}))})),i.querySelectorAll("a").forEach((function(n){n.addEventListener("click",(function(n){var t=document.getElementById("selector-scene"),o=t.options[t.selectedIndex].text,r=document.getElementById("selector-shader-editor-".concat(t.value)),i=r.options[r.selectedIndex].text;e.SUBMIT_SHADER.forEach((function(n){return n(o,i)}))}))})),i.querySelector("#selector-shader-editor-2d").addEventListener("change",(function(n){var t=oe("selector-shader-editor-2d");e.SELECT_SHADER_2D.forEach((function(n){return n(t)}))})),i.querySelector("#selector-shader-editor-3d").addEventListener("change",(function(n){var t=oe("selector-shader-editor-3d");e.SELECT_SHADER_3D.forEach((function(n){return n(t)}))})),r.querySelector("#selector-scene").addEventListener("change",(function(n){var t,o,r=oe("selector-scene");t="2D"!==r,(o=document.getElementById("model-loader"))&&(o.style.display=t?"block":"none"),function(n){var e="3D"===n,t=document.getElementById("editor-2d"),o=document.getElementById("editor-3d");t.style.display=e?"none":"block",o.style.display=e?"block":"none"}(r),e.SELECT_SCENE.forEach((function(n){return n(r)}))})),r.querySelector("#model-editor-submit").addEventListener("click",(function(n){e.UPDATE_MODEL.forEach((function(n){return n()}))})),{rootElement:t,addListener:function(n,t){n in e||(e[n]=[]),e[n].push(t)}}},ve=function(){function n(e){un()(this,n),this.gl=e,this.geometries=[],this.sceneObjects=[],this.light=null,this.skybox=null,this.particleSystem=[]}return vn()(n,[{key:"addSceneObject",value:function(n){this.sceneObjects.push(n)}},{key:"addGeometry",value:function(n){this.geometries.push(n)}},{key:"addParticles",value:function(n){this.particleSystem.push(n)}},{key:"setLight",value:function(n){this.light=n}},{key:"clear",value:function(){this.geometries=[],this.sceneObjects=[],this.skybox=null,this.particleSystem=[],this.light=null}},{key:"updateAnimation",value:function(){this.sceneObjects.forEach((function(n){n.updateAnimation()})),this.geometries.forEach((function(n){n.visible&&n.updateAnimation()})),this.skybox&&this.skybox.updateAnimation()}}]),n}();var me=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.position,t=n.target;this.position=new Float32Array(e||[0,0,10]),this.target=new Float32Array(t||[0,0,0]),this.worldUp=new Float32Array([0,1,0]),this.up=new Float32Array([0,1,0]),this.front=new Float32Array([0,0,-1]),this.right=new Float32Array([0,0,0]),this.yaw=-90,this.pitch=0,this.fov=60,this.near=.1,this.far=1e3,this.aspectRatio=1.2,this.viewMatrix=new Vn,this.projectionMatrix=new Vn,this.projectionMatrix.setPerspective(this.fov,this.aspectRatio,this.near,this.far),this.viewProjectionInvMatrix=new Vn,this.deltaTime=0,this.lastTime=performance.now(),this.rotationSpeed=.5,this.speed=.02,this.sensitivity=100,this.update()};me.prototype.setPosition=function(n){this.position=new Float32Array(n),this.updateViewMatrix()},me.prototype.setTarget=function(n){this.target=new Float32Array(n),this.updateViewMatrix()},me.prototype.setPerspective=function(n,e,t,o){this.fov=n,this.near=t,this.far=o,this.aspectRatio=e,this.updateProjectionMatrix()},me.prototype.setAspectRatio=function(n){this.aspectRatio=n,this.updateProjectionMatrix()},me.prototype.move=function(n){var e=this.speed*this.deltaTime;"forward"==n?(this.position[0]+=this.front[0]*e,this.position[1]+=this.front[1]*e,this.position[2]+=this.front[2]*e):"backward"==n?(this.position[0]-=this.front[0]*e,this.position[1]-=this.front[1]*e,this.position[2]-=this.front[2]*e):"left"==n?(this.position[0]+=this.right[0]*e,this.position[1]+=this.right[1]*e,this.position[2]+=this.right[2]*e):"right"==n&&(this.position[0]-=this.right[0]*e,this.position[1]-=this.right[1]*e,this.position[2]-=this.right[2]*e),this.updateViewMatrix()},me.prototype.rotate=function(n){var e=this.rotationSpeed*this.deltaTime;"left"==n?this.yaw-=e:"right"==n?this.yaw+=e:"up"==n?this.pitch+=e:"down"==n&&(this.pitch-=e),this.pitch>89.9&&(this.pitch=89.9),this.pitch<-89.9&&(this.pitch=-89.9),this.update()},me.prototype.rotateWithMouse=function(n,e){this.yaw+=n*this.sensitivity,this.pitch+=e*this.sensitivity,this.pitch>89.9&&(this.pitch=89.9),this.pitch<-89.9&&(this.pitch=-89.9),this.update()},me.prototype.zoom=function(n){(this.fov>1||this.fov<45)&&(this.fov+=n)},me.prototype.update=function(){var n=Math.cos(this.pitch*Math.PI/180),e=Math.sin(this.pitch*Math.PI/180),t=Math.cos(this.yaw*Math.PI/180),o=Math.sin(this.yaw*Math.PI/180);this.front[0]=t*n,this.front[1]=e,this.front[2]=o*n,this.front=this.normalize(this.front),this.getRight(),this.getUp(),this.updateViewMatrix(),this.updateViewProjectionInvMatrix()},me.prototype.getTarget=function(){var n=new Float32Array([0,0,0]);return n[0]=this.front[0]+this.position[0],n[1]=this.front[1]+this.position[1],n[2]=this.front[2]+this.position[2],this.target=n,this.target},me.prototype.getFront=function(){var n=new Float32Array([0,0,0]);return n[0]=this.target[0]-this.position[0],n[1]=this.target[1]-this.position[1],n[2]=this.target[2]-this.position[2],this.front=this.normalize(n),this.front},me.prototype.getRight=function(){var n=new Float32Array([0,0,0]),e=this.front[0],t=this.front[1],o=this.front[2],r=this.worldUp[0],i=this.worldUp[1],a=this.worldUp[2];return n[0]=t*a-o*i,n[1]=o*r-e*a,n[2]=e*i-t*r,this.right=this.normalize(n),this.right},me.prototype.getUp=function(){var n=new Float32Array([0,0,0]),e=this.right[0],t=this.right[1],o=this.right[2],r=this.front[0],i=this.front[1],a=this.front[2];return n[0]=t*a-o*i,n[1]=o*r-e*a,n[2]=e*i-t*r,this.up=this.normalize(n),this.up},me.prototype.normalize=function(n){var e=n[0],t=n[1],o=n[2],r=e*e+t*t+o*o,i=new Float32Array(3);return r>0&&(r=1/Math.sqrt(r),i[0]=n[0]*r,i[1]=n[1]*r,i[2]=n[2]*r),i},me.prototype.updateProjectionMatrix=function(){this.projectionMatrix.setPerspective(this.fov,this.aspectRatio,this.near,this.far)},me.prototype.updateViewMatrix=function(){this.getTarget(),this.viewMatrix.setLookAt(this.position[0],this.position[1],this.position[2],this.target[0],this.target[1],this.target[2],this.up[0],this.up[1],this.up[2])},me.prototype.updateViewProjectionInvMatrix=function(){var n=new Vn;n.set(this.projectionMatrix);var e=new Vn;e.set(this.viewMatrix),e[12]=0,e[13]=0,e[14]=0,e[15]=1,n.concat(e),this.viewProjectionInvMatrix.setInverseOf(n)},me.prototype.getViewDistance=function(n){return Math.sqrt(Math.pow(n[0]-this.position[0],2)+Math.pow(n[1]-this.position[1],2)+Math.pow(n[2]-this.position[2],2))},me.prototype.getViewDistanceXZ=function(n){return Math.sqrt(Math.pow(n[0]-this.position[0],2)+Math.pow(n[2]-this.position[2],2))},me.prototype.updateAnimation=function(){var n=performance.now();this.deltaTime=n-this.lastTime,this.lastTime=n};const de=me;function pe(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,o)}return t}const he=function n(e,t){un()(this,n),this.image=e,this.textureObj=null,this.properties=function(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?pe(Object(t),!0).forEach((function(e){i()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):pe(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}({minParam:"LINEAR",magParam:"LINEAR",wrapSParam:"REPEAT",wrapTParam:"REPEAT"},t)};function ge(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,o)}return t}const xe=function(n){Fn()(r,n);var e,t,o=(e=r,t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(n){return!1}}(),function(){var n,o=zn()(e);if(t){var r=zn()(this).constructor;n=Reflect.construct(o,arguments,r)}else n=o.apply(this,arguments);return Ln()(this,n)});function r(n,e){var t;return un()(this,r),(t=o.call(this)).image=n,t.textureObj=null,t.properties=function(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?ge(Object(t),!0).forEach((function(e){i()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):ge(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}({minParam:"LINEAR",magParam:"LINEAR",wrapSParam:"CLAMP_TO_EDGE",wrapTParam:"CLAMP_TO_EDGE",wrapRParam:"CLAMP_TO_EDGE"},e),t}return r}(he),ye=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};un()(this,n);var t=e.position,o=e.color,r=e.specularColor;this.position=new Float32Array(t||[0,10,5]),this.color=new Float32Array(o||[1,1,1]),this.specularColor=new Float32Array(r||[1,1,1]),this.lightSpaceMatrix=null,this.near=1,this.far=10}return vn()(n,[{key:"setPosition",value:function(n){this.position=new Float32Array(n)}},{key:"setLightColor",value:function(n){this.color=new Float32Array(n)}},{key:"setSpecularColor",value:function(n){this.specularColor=new Float32Array(n)}},{key:"updateMatrix",value:function(){var n=(new Vn).setOrtho(-10,10,-10,10,this.near,this.far),e=(new Vn).setLookAt(this.position[0],this.position[1],this.position[2],0,0,0,0,1,0);this.lightSpaceMatrix=n.multiply(e)}}]),n}();const be=function(n){Fn()(r,n);var e,t,o=(e=r,t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(n){return!1}}(),function(){var n,o=zn()(e);if(t){var r=zn()(this).constructor;n=Reflect.construct(o,arguments,r)}else n=o.apply(this,arguments);return Ln()(this,n)});function r(){var n;return un()(this,r),(n=o.call(this)).generateCubeVertices(),n}return vn()(r,[{key:"generateCubeVertices",value:function(){this.vertices=[-1,-1,-1,1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,1,1,1,-1,1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,-1,-1,1,1,-1,1,-1,-1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,1,1,-1,1,1,1,-1,1,-1,-1,1,1],this.UVs=[0,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,1,0,1,0,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0],this.normals=[0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0]}}]),r}(Wn);var Ce=t(3038),_e=t.n(Ce),Ae=function(n,e,t){for(var o={},r=[],i=0;i<t.length;i+=3){var a=t[i],c=t[i+1],s=t[i+2],u=new jn(n.slice(3*a,3*a+3)),f=new jn(n.slice(3*c,3*c+3)),v=new jn(n.slice(3*s,3*s+3)),m=new Bn(e.slice(2*a,2*a+2)),d=new Bn(e.slice(2*c,2*c+2)),p=new Bn(e.slice(2*s,2*s+2)),h=f.subtract(u),g=v.subtract(u),x=d.subtract(m).elements,y=p.subtract(m).elements,b=null,C=1/(x[0]*y[1]-x[1]*y[0]);b=(b=h.scale(y[1]).subtract(g.scale(x[1]))).scale(C);for(var _=0;_<3;++_){var A=t[i+_];o[A]=A in o?o[A].add(b):b}}for(var w=0;w<Object.keys(o).length;++w)r.push.apply(r,l()(o[w].elements));return r};const we=function(n){Fn()(r,n);var e,t,o=(e=r,t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(n){return!1}}(),function(){var n,o=zn()(e);if(t){var r=zn()(this).constructor;n=Reflect.construct(o,arguments,r)}else n=o.apply(this,arguments);return Ln()(this,n)});function r(n){var e;return un()(this,r),e=o.call(this),n&&(e.vertices=n.vertices||[],e.UVs=n.texCoords||[],e.normals=n.normals||[],e.indices=n.indices||[],e.colors=n.colors||[],e.tangents=n.tangents||[],0===e.tangents.length&&(e.tangents=Ae(e.vertices,e.UVs,e.indices))),e}return r}(Wn);function Ee(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,o)}return t}function Se(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?Ee(Object(t),!0).forEach((function(e){i()(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):Ee(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var Te=function(n){var e=n.get(),t=e.model,o=e.currentModel,r=e.cameraInfo,i=e.lightInfo,a=t[o],c=new ve,s=new de(Se({},r));if(s.setPerspective(40,2,.1,100),s.setPosition([0,0,1]),"custom"===a.modelType){var u=function(n){var e=n.model,t=n.shaders,o=e[n.currentModel];if(!o.text)return null;var r=o.model;r||(r=function(n){for(var e=[[0,0,0]],t=[[0,0]],o=[[0,0,0]],r=(arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}).textureStride||2,i=[e,t,o],a=[[],[],[]],c={},s=[],u=function(n){var e=n.split("/").map((function(n,e){if(n){var t=parseInt(n);return t+(t>=0?0:i[e].length)}})),t=e.join(","),o=c[t];o||(o=a[0].length/3,c[t]=o,e.forEach((function(n,e){var t;n&&(t=a[e]).push.apply(t,l()(i[e][n]))}))),s.push(o)},f=function(n){for(var e=n.length-2,t=0;t<e;++t)u(n[0]),u(n[t+1]),u(n[t+2])},v={v:function(n){e.push(n.map(parseFloat))},vn:function(n){o.push(n.map(parseFloat))},vt:function(n){var e=n.slice(0,r);t.push(e.map(parseFloat))},s:function(){},f:function(n){f(n)}},m=/(\w*)(?: )*(.*)/,d=n.split("\n"),p=0;p<d.length;++p){var h=d[p].trim();if(""!==h&&!h.startsWith("#")){var g=m.exec(h);if(g){var x=_e()(g,3),y=x[1],b=x[2],C=h.split(/\s+/).slice(1),_=v[y];_?_(C,b):console.warn("unhandled keyword ".concat(y," at line ").concat(p+1))}}}var A=Ae(a[0],a[1],s);return{vertices:a[0],texCoords:a[1],normals:a[2],tangents:A,indices:s}}(o.text),o.model=r);var i=new we(r),a=o.transform,c=a.translate||[0,0,0],s=a.scale||[1,1,1],u=a.rotateDegree||0,f=a.rotateAxis||[0,1,0],v=a.autoRotate||!1;i.translate(c),i.scale(s),i.rotate(u,f),i.autoRotate=v;var m={u_model:{type:"mat4",value:i.modelMatrix},u_normalMatrix:{type:"mat4",value:i.normalMatrix}},d=o.textures;Object.keys(d).forEach((function(n){d[n].img&&(m["u_".concat(n)]={type:"texture",value:new he(d[n].img)})}));var p=new On({uniforms:m,shaders:t["3D"].PBR});return i.addMaterial(p),i}(e);c.addGeometry(u)}else{var f=function(n,e){var t=e.translate,o=void 0===t?[0,0,0]:t,r=e.scale,i=void 0===r?[1,1,1]:r,a=e.rotateDegree,c=void 0===a?0:a,s=e.rotateAxis,l=void 0===s?[0,1,0]:s,u=e.autoRotate,f=void 0!==u&&u,v=new be,m=n.images,d=n.shaders,p=m.wood.img,h={u_model:{type:"mat4",value:v.modelMatrix},u_normalMatrix:{type:"mat4",value:v.normalMatrix},u_sample:{type:"texture",value:new he(p)}},g=d["3D"].BasicLight,x=new On({uniforms:h,shaders:g});return v.addMaterial(x),v.translate(o),v.rotate(c,l),v.scale(i),v.autoRotate=f,v}(e,{translate:[-2,-1,-5],scale:[.5,.5,.5],rotateDegree:30,rotateAxis:[0,0,1],autoRotate:!0});c.addGeometry(f)}var v=function(n,e){var t=e.translate,o=void 0===t?[0,0,0]:t,r=e.scale,i=void 0===r?[1,1,1]:r,a=e.rotateDegree,c=void 0===a?0:a,s=e.rotateAxis,l=void 0===s?[0,1,0]:s,u=e.autoRotate,f=void 0!==u&&u,v=new Yn,m=n.shaders,d={u_model:{type:"mat4",value:v.modelMatrix},u_normalMatrix:{type:"mat4",value:v.normalMatrix},u_color:{type:"v3",value:[.8,.8,.8]}},p=m["3D"].SimpleColor,h=new On({uniforms:d,shaders:p});return v.addMaterial(h),v.translate(o),v.rotate(c,l),v.scale(i),v.autoRotate=f,v}(e,{translate:[0,-3,0],scale:[50,50,50],rotateDegree:-90,rotateAxis:[1,0,0]});c.addGeometry(v);var m,d,p,h,g,x,y,b,C=(m=e,d=new Yn,p=m.images,h=m.shaders,g=p.noise64.img,x=h["3D"].Sky,y={u_noisemap:{type:"texture",value:new he(g)},u_time:{type:"t",value:0}},b=new On({uniforms:y,shaders:x}),d.addMaterial(b),d);c.skybox=C;var _=new ye(Se({},i));return c.setLight(_),{scene:c,camera:s}},Ie=function(n,e,t){if("3D"===e){var o=Te(t),r=o.scene,i=o.camera;n.init(r,i)}else{var a=function(n){var e=new ve,t=new de,o=new Yn,r=n.get(),i=r.textures,a=r.images,c=r.cubemaps,s=r.cubemapTextures,l={u_time:{type:"t"},u_mouse:{type:"mouse"},u_resolution:{type:"resolution"}},u=r.currentShader["2D"],f=r.shaders["2D"][u];u in i&&i[u].forEach((function(n,e){l["u_sample".concat(0===e?"":e)]={type:"texture",value:new he(a[n].img)}})),u in s&&s[u].forEach((function(n,e){l["u_cubemap".concat(0===e?"":e)]={type:"cubemap",value:new xe(c[n])}}));var v=new On({uniforms:l,shaders:f});return o.addMaterial(v),e.addGeometry(o),{scene:e,camera:t}}(t),c=a.scene,s=a.camera;n.init(c,s)}},De=function(n){return Object.keys(n).map((function(e){return n[e].path?new Promise((function(t,o){var r=new Image;r.addEventListener("load",(function(){return t({img:r,key:e})})),r.addEventListener("error",(function(n){return o(n)})),r.src=n[e].path})).then((function(e){var t=e.img,o=e.key;return n[o].img=t,{img:t,key:o}})):null}))};window.onload=function(){var n=[],e=sn.getById("model");Object.keys(e).forEach((function(t){var o=e[t],r=o.textures;(n=n.concat(De(r))).push(function(n){return fetch(n.path).then((function(n){return n.text()})).then((function(e){return n.text=e,e}))}(o))}));var t=sn.getById("images");n=n.concat(De(t));var o=sn.getById("cubemaps");return Object.keys(o).forEach((function(e){var t=o[e];n=n.concat(De(t))})),Promise.all(n).then((function(){var n,o,r;sn.setDataById("model",e),sn.setDataById("images",t),n=new Zn("webgl-canvas"),o=fe(sn),r=sn.getById("currentScene"),Ie(n,r,sn),window.addEventListener("resize",(function(){n.resizeCanvas()}),!1),o.addListener("SUBMIT_SHADER",(function(e,t){if(sessionStorage&&"textarea-".concat(t)in sessionStorage){var o=sn.getById("shaders");o[e][t].fragment=sessionStorage["textarea-".concat(t)],sn.setDataById("shaders",o)}Ie(n,e,sn)})),o.addListener("SELECT_SCENE",(function(e){Ie(n,e,sn)})),o.addListener("UPDATE_MODEL",(function(){Ie(n,"3D",sn)})),o.addListener("SELECT_SHADER_2D",(function(n){var e=sn.getById("currentShader");e["2D"]=n,sn.setDataById("currentShader",e)})),o.addListener("SELECT_SHADER_3D",(function(n){var e=sn.getById("currentShader");e["3D"]=n,sn.setDataById("currentShader",e)})),function e(){requestAnimationFrame(e),n.render()}()})).catch((function(n){console.log("Error occurred when loading static files: ",n)})),!0}(),window.requestAnimationFrame||(window.requestAnimationFrame=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n,e){window.setTimeout(n,1e3/60)}),window.cancelAnimationFrame||(window.cancelAnimationFrame=window.cancelRequestAnimationFrame||window.webkitCancelAnimationFrame||window.webkitCancelRequestAnimationFrame||window.mozCancelAnimationFrame||window.mozCancelRequestAnimationFrame||window.msCancelAnimationFrame||window.msCancelRequestAnimationFrame||window.oCancelAnimationFrame||window.oCancelRequestAnimationFrame||window.clearTimeout)})()})();
//# sourceMappingURL=main.bundle.js.map